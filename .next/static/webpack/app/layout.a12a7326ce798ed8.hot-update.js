"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/lib/contentstack/personalize.ts":
/*!*********************************************!*\
  !*** ./src/lib/contentstack/personalize.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPersonalizedContent: function() { return /* binding */ getPersonalizedContent; },\n/* harmony export */   getPersonalizedOpportunities: function() { return /* binding */ getPersonalizedOpportunities; },\n/* harmony export */   getUserAttributesFromClient: function() { return /* binding */ getUserAttributesFromClient; },\n/* harmony export */   storeUserAttributes: function() { return /* binding */ storeUserAttributes; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(app-pages-browser)/./src/lib/contentstack/config.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Contentstack Personalize Integration\n * \n * Provides utilities for fetching personalized content based on user attributes\n * \n * Setup:\n * 1. Enable Personalize in your Contentstack stack\n * 2. Add CONTENTSTACK_PERSONALIZE_API_KEY to .env.local\n * 3. Create user segments in Contentstack Personalize\n * 4. Add Personalize fields to your content types\n */ \n/**\n * Get personalized content from Contentstack\n * \n * @param contentTypeUid - Content type UID (e.g., 'landing_page')\n * @param userAttributes - User attributes for personalization\n * @param options - Additional options\n * @returns Personalized content entry\n */ async function getPersonalizedContent(contentTypeUid, userAttributes) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const config = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getContentstackConfig)();\n    const baseUrl = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)();\n    const environment = options.environment || config.environment;\n    const locale = options.locale || \"en-us\";\n    // Build Personalize API URL\n    const personalizeApiKey = process.env.CONTENTSTACK_PERSONALIZE_API_KEY;\n    if (!personalizeApiKey) {\n        console.warn(\"CONTENTSTACK_PERSONALIZE_API_KEY not set. Returning default content.\");\n        // Fallback to regular content fetch\n        return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n    }\n    const endpoint = options.entryUid ? \"/content_types/\".concat(contentTypeUid, \"/entries/\").concat(options.entryUid) : \"/content_types/\".concat(contentTypeUid, \"/entries\");\n    const url = \"\".concat(baseUrl, \"/v3\").concat(endpoint, \"?environment=\").concat(environment, \"&locale=\").concat(locale);\n    // Build headers with Personalize API key\n    const headers = {\n        \"api_key\": config.apiKey,\n        \"access_token\": config.deliveryToken,\n        \"personalization_api_key\": personalizeApiKey,\n        \"Content-Type\": \"application/json\"\n    };\n    // Add user attributes as query parameters or headers\n    // Contentstack Personalize accepts user attributes in the request\n    const searchParams = new URLSearchParams();\n    if (userAttributes) {\n        // Add user attributes as query parameters\n        Object.entries(userAttributes).forEach((param)=>{\n            let [key, value] = param;\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    value.forEach((v)=>searchParams.append(\"user_attributes[\".concat(key, \"][]\"), String(v)));\n                } else {\n                    searchParams.append(\"user_attributes[\".concat(key, \"]\"), String(value));\n                }\n            }\n        });\n    }\n    const fullUrl = searchParams.toString() ? \"\".concat(url, \"&\").concat(searchParams.toString()) : url;\n    try {\n        var _data_entries;\n        const response = await fetch(fullUrl, {\n            headers,\n            next: {\n                revalidate: 60\n            }\n        });\n        if (!response.ok) {\n            console.warn(\"Personalize API error: \".concat(response.status, \". Falling back to default content.\"));\n            return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n        }\n        const data = await response.json();\n        return (options.entryUid ? data.entry : (_data_entries = data.entries) === null || _data_entries === void 0 ? void 0 : _data_entries[0]) || data;\n    } catch (error) {\n        console.error(\"Error fetching personalized content:\", error);\n        // Fallback to default content\n        return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n    }\n}\n/**\n * Fallback: Get default (non-personalized) content\n */ async function getDefaultContent(contentTypeUid, entryUid, environment, locale) {\n    var _data_entries;\n    const config = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getContentstackConfig)();\n    const baseUrl = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)();\n    const endpoint = entryUid ? \"/content_types/\".concat(contentTypeUid, \"/entries/\").concat(entryUid) : \"/content_types/\".concat(contentTypeUid, \"/entries\");\n    const url = \"\".concat(baseUrl, \"/v3\").concat(endpoint, \"?environment=\").concat(environment, \"&locale=\").concat(locale);\n    const response = await fetch(url, {\n        headers: {\n            \"api_key\": config.apiKey,\n            \"access_token\": config.deliveryToken\n        },\n        next: {\n            revalidate: 60\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch default content: \".concat(response.status));\n    }\n    const data = await response.json();\n    return (entryUid ? data.entry : (_data_entries = data.entries) === null || _data_entries === void 0 ? void 0 : _data_entries[0]) || data;\n}\n/**\n * Get user attributes from client-side storage (localStorage, cookies, etc.)\n * This is a helper function for client components\n */ function getUserAttributesFromClient() {\n    if (false) {}\n    const attributes = {};\n    // Get from localStorage\n    const storedCity = localStorage.getItem(\"userCity\");\n    const storedInterests = localStorage.getItem(\"userInterests\");\n    const storedUserType = localStorage.getItem(\"userType\");\n    if (storedCity) attributes.city = storedCity;\n    if (storedInterests) {\n        try {\n            attributes.interests = JSON.parse(storedInterests);\n        } catch (e) {\n        // Ignore parse errors\n        }\n    }\n    if (storedUserType) {\n        attributes.userType = storedUserType;\n    }\n    // Get from cookies (if using a cookie library)\n    // You can add cookie parsing here if needed\n    return attributes;\n}\n/**\n * Store user attributes in client-side storage\n */ function storeUserAttributes(attributes) {\n    if (false) {}\n    if (attributes.city) {\n        localStorage.setItem(\"userCity\", attributes.city);\n    }\n    if (attributes.interests) {\n        localStorage.setItem(\"userInterests\", JSON.stringify(attributes.interests));\n    }\n    if (attributes.userType) {\n        localStorage.setItem(\"userType\", attributes.userType);\n    }\n}\n/**\n * Get personalized opportunities based on user attributes\n * This combines regular opportunity fetching with personalization\n */ async function getPersonalizedOpportunities(userAttributes, filters) {\n    // First, get personalized content for opportunity recommendations\n    // Then fetch actual opportunities based on personalized preferences\n    // This is a placeholder - implement based on your Personalize setup\n    // You might want to:\n    // 1. Get personalized cause preferences\n    // 2. Get personalized location preferences\n    // 3. Fetch opportunities matching those preferences\n    return [];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGVudHN0YWNrL3BlcnNvbmFsaXplLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FFK0Q7QUF1Q2hFOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRSx1QkFDcEJDLGNBQXNCLEVBQ3RCQyxjQUErQjtRQUMvQkMsVUFBQUEsaUVBQXlFLENBQUM7SUFFMUUsTUFBTUMsU0FBU04sOERBQXFCQTtJQUNwQyxNQUFNTyxVQUFVTixzREFBYUE7SUFDN0IsTUFBTU8sY0FBY0gsUUFBUUcsV0FBVyxJQUFJRixPQUFPRSxXQUFXO0lBQzdELE1BQU1DLFNBQVNKLFFBQVFJLE1BQU0sSUFBSTtJQUVqQyw0QkFBNEI7SUFDNUIsTUFBTUMsb0JBQW9CQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLGdDQUFnQztJQUV0RSxJQUFJLENBQUNILG1CQUFtQjtRQUN0QkksUUFBUUMsSUFBSSxDQUFDO1FBQ2Isb0NBQW9DO1FBQ3BDLE9BQU9DLGtCQUFxQmIsZ0JBQWdCRSxRQUFRWSxRQUFRLEVBQUVULGFBQWFDO0lBQzdFO0lBRUEsTUFBTVMsV0FBV2IsUUFBUVksUUFBUSxHQUM3QixrQkFBNENaLE9BQTFCRixnQkFBZSxhQUE0QixPQUFqQkUsUUFBUVksUUFBUSxJQUM1RCxrQkFBaUMsT0FBZmQsZ0JBQWU7SUFFckMsTUFBTWdCLE1BQU0sR0FBZ0JELE9BQWJYLFNBQVEsT0FBNkJDLE9BQXhCVSxVQUFTLGlCQUFxQ1QsT0FBdEJELGFBQVksWUFBaUIsT0FBUEM7SUFFMUUseUNBQXlDO0lBQ3pDLE1BQU1XLFVBQXVCO1FBQzNCLFdBQVdkLE9BQU9lLE1BQU07UUFDeEIsZ0JBQWdCZixPQUFPZ0IsYUFBYTtRQUNwQywyQkFBMkJaO1FBQzNCLGdCQUFnQjtJQUNsQjtJQUVBLHFEQUFxRDtJQUNyRCxrRUFBa0U7SUFDbEUsTUFBTWEsZUFBZSxJQUFJQztJQUV6QixJQUFJcEIsZ0JBQWdCO1FBQ2xCLDBDQUEw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QUk7WUFDRkosV0FBV08sU0FBUyxHQUFHQyxLQUFLQyxLQUFLLENBQUNMO1FBQ3BDLEVBQUUsVUFBTTtRQUNOLHNCQUFzQjtRQUN4QjtJQUNGO0lBQ0EsSUFBSUMsZ0JBQWdCO1FBQ2xCTCxXQUFXVSxRQUFRLEdBQUdMO0lBQ3hCO0lBRUEsK0NBQStDO0lBQy9DLDRDQUE0QztJQUU1QyxPQUFPTDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTVyxvQkFBb0JYLFVBQW1DO0lBQ3JFLElBQUksS0FBa0IsRUFBYSxFQUFPO0lBRTFDLElBQUlBLFdBQVdNLElBQUksRUFBRTtRQUNuQkosYUFBYVUsT0FBTyxDQUFDLFlBQVlaLFdBQVdNLElBQUk7SUFDbEQ7SUFFQSxJQUFJTixXQUFXTyxTQUFTLEVBQUU7UUFDeEJMLGFBQWFVLE9BQU8sQ0FBQyxpQkFBaUJKLEtBQUtLLFNBQVMsQ0FBQ2IsV0FBV08sU0FBUztJQUMzRTtJQUVBLElBQUlQLFdBQVdVLFFBQVEsRUFBRTtRQUN2QlIsYUFBYVUsT0FBTyxDQUFDLFlBQVlaLFdBQVdVLFFBQVE7SUFDdEQ7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLGVBQWVJLDZCQUNwQjVELGNBQStCLEVBQy9CNkQsT0FHQztJQUVELGtFQUFrRTtJQUNsRSxvRUFBb0U7SUFFcEUsb0VBQW9FO0lBQ3BFLHFCQUFxQjtJQUNyQix3Q0FBd0M7SUFDeEMsMkNBQTJDO0lBQzNDLG9EQUFvRDtJQUVwRCxPQUFPLEVBQUU7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2NvbnRlbnRzdGFjay9wZXJzb25hbGl6ZS50cz9mYzRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udGVudHN0YWNrIFBlcnNvbmFsaXplIEludGVncmF0aW9uXG4gKiBcbiAqIFByb3ZpZGVzIHV0aWxpdGllcyBmb3IgZmV0Y2hpbmcgcGVyc29uYWxpemVkIGNvbnRlbnQgYmFzZWQgb24gdXNlciBhdHRyaWJ1dGVzXG4gKiBcbiAqIFNldHVwOlxuICogMS4gRW5hYmxlIFBlcnNvbmFsaXplIGluIHlvdXIgQ29udGVudHN0YWNrIHN0YWNrXG4gKiAyLiBBZGQgQ09OVEVOVFNUQUNLX1BFUlNPTkFMSVpFX0FQSV9LRVkgdG8gLmVudi5sb2NhbFxuICogMy4gQ3JlYXRlIHVzZXIgc2VnbWVudHMgaW4gQ29udGVudHN0YWNrIFBlcnNvbmFsaXplXG4gKiA0LiBBZGQgUGVyc29uYWxpemUgZmllbGRzIHRvIHlvdXIgY29udGVudCB0eXBlc1xuICovXG5cbmltcG9ydCB7IGdldENvbnRlbnRzdGFja0NvbmZpZywgZ2V0QXBpQmFzZVVybCB9IGZyb20gJy4vY29uZmlnJztcblxuZXhwb3J0IGludGVyZmFjZSBVc2VyQXR0cmlidXRlcyB7XG4gIC8vIExvY2F0aW9uXG4gIGNpdHk/OiBzdHJpbmc7XG4gIHN0YXRlPzogc3RyaW5nO1xuICBjb3VudHJ5Pzogc3RyaW5nO1xuICBcbiAgLy8gSW50ZXJlc3RzICYgUHJlZmVyZW5jZXNcbiAgaW50ZXJlc3RzPzogc3RyaW5nW107XG4gIHByZWZlcnJlZENhdXNlcz86IHN0cmluZ1tdO1xuICBjb250cmlidXRpb25UeXBlcz86IHN0cmluZ1tdO1xuICBcbiAgLy8gVXNlciBCZWhhdmlvclxuICB1c2VyVHlwZT86ICduZXcnIHwgJ3JldHVybmluZycgfCAnYWN0aXZlJztcbiAgcmVnaXN0cmF0aW9uQ291bnQ/OiBudW1iZXI7XG4gIGxhc3RWaXNpdERhdGU/OiBzdHJpbmc7XG4gIFxuICAvLyBEZW1vZ3JhcGhpY3MgKG9wdGlvbmFsKVxuICBhZ2U/OiBudW1iZXI7XG4gIGxhbmd1YWdlPzogc3RyaW5nO1xuICBcbiAgLy8gQ3VzdG9tIGF0dHJpYnV0ZXNcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc29uYWxpemVPcHRpb25zIHtcbiAgLyoqIFVzZXIgYXR0cmlidXRlcyBmb3IgcGVyc29uYWxpemF0aW9uICovXG4gIHVzZXJBdHRyaWJ1dGVzPzogVXNlckF0dHJpYnV0ZXM7XG4gIC8qKiBDb250ZW50IHR5cGUgVUlEICovXG4gIGNvbnRlbnRUeXBlVWlkOiBzdHJpbmc7XG4gIC8qKiBFbnRyeSBVSUQgKG9wdGlvbmFsLCBmb3Igc3BlY2lmaWMgZW50cnkpICovXG4gIGVudHJ5VWlkPzogc3RyaW5nO1xuICAvKiogRW52aXJvbm1lbnQgKGRlZmF1bHRzIHRvIGNvbmZpZ3VyZWQgZW52aXJvbm1lbnQpICovXG4gIGVudmlyb25tZW50Pzogc3RyaW5nO1xuICAvKiogTG9jYWxlIChkZWZhdWx0cyB0byAnZW4tdXMnKSAqL1xuICBsb2NhbGU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogR2V0IHBlcnNvbmFsaXplZCBjb250ZW50IGZyb20gQ29udGVudHN0YWNrXG4gKiBcbiAqIEBwYXJhbSBjb250ZW50VHlwZVVpZCAtIENvbnRlbnQgdHlwZSBVSUQgKGUuZy4sICdsYW5kaW5nX3BhZ2UnKVxuICogQHBhcmFtIHVzZXJBdHRyaWJ1dGVzIC0gVXNlciBhdHRyaWJ1dGVzIGZvciBwZXJzb25hbGl6YXRpb25cbiAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJucyBQZXJzb25hbGl6ZWQgY29udGVudCBlbnRyeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGVyc29uYWxpemVkQ29udGVudDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICBjb250ZW50VHlwZVVpZDogc3RyaW5nLFxuICB1c2VyQXR0cmlidXRlcz86IFVzZXJBdHRyaWJ1dGVzLFxuICBvcHRpb25zOiBPbWl0PFBlcnNvbmFsaXplT3B0aW9ucywgJ2NvbnRlbnRUeXBlVWlkJyB8ICd1c2VyQXR0cmlidXRlcyc+ID0ge31cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBjb25maWcgPSBnZXRDb250ZW50c3RhY2tDb25maWcoKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEFwaUJhc2VVcmwoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50IHx8IGNvbmZpZy5lbnZpcm9ubWVudDtcbiAgY29uc3QgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgJ2VuLXVzJztcbiAgXG4gIC8vIEJ1aWxkIFBlcnNvbmFsaXplIEFQSSBVUkxcbiAgY29uc3QgcGVyc29uYWxpemVBcGlLZXkgPSBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfUEVSU09OQUxJWkVfQVBJX0tFWTtcbiAgXG4gIGlmICghcGVyc29uYWxpemVBcGlLZXkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0NPTlRFTlRTVEFDS19QRVJTT05BTElaRV9BUElfS0VZIG5vdCBzZXQuIFJldHVybmluZyBkZWZhdWx0IGNvbnRlbnQuJyk7XG4gICAgLy8gRmFsbGJhY2sgdG8gcmVndWxhciBjb250ZW50IGZldGNoXG4gICAgcmV0dXJuIGdldERlZmF1bHRDb250ZW50PFQ+KGNvbnRlbnRUeXBlVWlkLCBvcHRpb25zLmVudHJ5VWlkLCBlbnZpcm9ubWVudCwgbG9jYWxlKTtcbiAgfVxuICBcbiAgY29uc3QgZW5kcG9pbnQgPSBvcHRpb25zLmVudHJ5VWlkXG4gICAgPyBgL2NvbnRlbnRfdHlwZXMvJHtjb250ZW50VHlwZVVpZH0vZW50cmllcy8ke29wdGlvbnMuZW50cnlVaWR9YFxuICAgIDogYC9jb250ZW50X3R5cGVzLyR7Y29udGVudFR5cGVVaWR9L2VudHJpZXNgO1xuICBcbiAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0vdjMke2VuZHBvaW50fT9lbnZpcm9ubWVudD0ke2Vudmlyb25tZW50fSZsb2NhbGU9JHtsb2NhbGV9YDtcbiAgXG4gIC8vIEJ1aWxkIGhlYWRlcnMgd2l0aCBQZXJzb25hbGl6ZSBBUEkga2V5XG4gIGNvbnN0IGhlYWRlcnM6IEhlYWRlcnNJbml0ID0ge1xuICAgICdhcGlfa2V5JzogY29uZmlnLmFwaUtleSxcbiAgICAnYWNjZXNzX3Rva2VuJzogY29uZmlnLmRlbGl2ZXJ5VG9rZW4sXG4gICAgJ3BlcnNvbmFsaXphdGlvbl9hcGlfa2V5JzogcGVyc29uYWxpemVBcGlLZXksXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfTtcbiAgXG4gIC8vIEFkZCB1c2VyIGF0dHJpYnV0ZXMgYXMgcXVlcnkgcGFyYW1ldGVycyBvciBoZWFkZXJzXG4gIC8vIENvbnRlbnRzdGFjayBQZXJzb25hbGl6ZSBhY2NlcHRzIHVzZXIgYXR0cmlidXRlcyBpbiB0aGUgcmVxdWVzdFxuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIFxuICBpZiAodXNlckF0dHJpYnV0ZXMpIHtcbiAgICAvLyBBZGQgdXNlciBhdHRyaWJ1dGVzIGFzIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICBPYmplY3QuZW50cmllcyh1c2VyQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZS5mb3JFYWNoKHYgPT4gc2VhcmNoUGFyYW1zLmFwcGVuZChgdXNlcl9hdHRyaWJ1dGVzWyR7a2V5fV1bXWAsIFN0cmluZyh2KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoYHVzZXJfYXR0cmlidXRlc1ske2tleX1dYCwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgY29uc3QgZnVsbFVybCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpID8gYCR7dXJsfSYke3NlYXJjaFBhcmFtcy50b1N0cmluZygpfWAgOiB1cmw7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIG5leHQ6IHsgcmV2YWxpZGF0ZTogNjAgfSwgLy8gQ2FjaGUgZm9yIDYwIHNlY29uZHNcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFBlcnNvbmFsaXplIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9LiBGYWxsaW5nIGJhY2sgdG8gZGVmYXVsdCBjb250ZW50LmApO1xuICAgICAgcmV0dXJuIGdldERlZmF1bHRDb250ZW50PFQ+KGNvbnRlbnRUeXBlVWlkLCBvcHRpb25zLmVudHJ5VWlkLCBlbnZpcm9ubWVudCwgbG9jYWxlKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gKG9wdGlvbnMuZW50cnlVaWQgPyBkYXRhLmVudHJ5IDogZGF0YS5lbnRyaWVzPy5bMF0pIHx8IGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGVyc29uYWxpemVkIGNvbnRlbnQ6JywgZXJyb3IpO1xuICAgIC8vIEZhbGxiYWNrIHRvIGRlZmF1bHQgY29udGVudFxuICAgIHJldHVybiBnZXREZWZhdWx0Q29udGVudDxUPihjb250ZW50VHlwZVVpZCwgb3B0aW9ucy5lbnRyeVVpZCwgZW52aXJvbm1lbnQsIGxvY2FsZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWxsYmFjazogR2V0IGRlZmF1bHQgKG5vbi1wZXJzb25hbGl6ZWQpIGNvbnRlbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbnRlbnQ8VD4oXG4gIGNvbnRlbnRUeXBlVWlkOiBzdHJpbmcsXG4gIGVudHJ5VWlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGVudmlyb25tZW50OiBzdHJpbmcsXG4gIGxvY2FsZTogc3RyaW5nXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgY29uZmlnID0gZ2V0Q29udGVudHN0YWNrQ29uZmlnKCk7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRBcGlCYXNlVXJsKCk7XG4gIFxuICBjb25zdCBlbmRwb2ludCA9IGVudHJ5VWlkXG4gICAgPyBgL2NvbnRlbnRfdHlwZXMvJHtjb250ZW50VHlwZVVpZH0vZW50cmllcy8ke2VudHJ5VWlkfWBcbiAgICA6IGAvY29udGVudF90eXBlcy8ke2NvbnRlbnRUeXBlVWlkfS9lbnRyaWVzYDtcbiAgXG4gIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9L3YzJHtlbmRwb2ludH0/ZW52aXJvbm1lbnQ9JHtlbnZpcm9ubWVudH0mbG9jYWxlPSR7bG9jYWxlfWA7XG4gIFxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICdhcGlfa2V5JzogY29uZmlnLmFwaUtleSxcbiAgICAgICdhY2Nlc3NfdG9rZW4nOiBjb25maWcuZGVsaXZlcnlUb2tlbixcbiAgICB9LFxuICAgIG5leHQ6IHsgcmV2YWxpZGF0ZTogNjAgfSxcbiAgfSk7XG4gIFxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGVmYXVsdCBjb250ZW50OiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgfVxuICBcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgcmV0dXJuIChlbnRyeVVpZCA/IGRhdGEuZW50cnkgOiBkYXRhLmVudHJpZXM/LlswXSkgfHwgZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdXNlciBhdHRyaWJ1dGVzIGZyb20gY2xpZW50LXNpZGUgc3RvcmFnZSAobG9jYWxTdG9yYWdlLCBjb29raWVzLCBldGMuKVxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgY2xpZW50IGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBdHRyaWJ1dGVzRnJvbUNsaWVudCgpOiBVc2VyQXR0cmlidXRlcyB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBcbiAgY29uc3QgYXR0cmlidXRlczogVXNlckF0dHJpYnV0ZXMgPSB7fTtcbiAgXG4gIC8vIEdldCBmcm9tIGxvY2FsU3RvcmFnZVxuICBjb25zdCBzdG9yZWRDaXR5ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJDaXR5Jyk7XG4gIGNvbnN0IHN0b3JlZEludGVyZXN0cyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VySW50ZXJlc3RzJyk7XG4gIGNvbnN0IHN0b3JlZFVzZXJUeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJUeXBlJyk7XG4gIFxuICBpZiAoc3RvcmVkQ2l0eSkgYXR0cmlidXRlcy5jaXR5ID0gc3RvcmVkQ2l0eTtcbiAgaWYgKHN0b3JlZEludGVyZXN0cykge1xuICAgIHRyeSB7XG4gICAgICBhdHRyaWJ1dGVzLmludGVyZXN0cyA9IEpTT04ucGFyc2Uoc3RvcmVkSW50ZXJlc3RzKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElnbm9yZSBwYXJzZSBlcnJvcnNcbiAgICB9XG4gIH1cbiAgaWYgKHN0b3JlZFVzZXJUeXBlKSB7XG4gICAgYXR0cmlidXRlcy51c2VyVHlwZSA9IHN0b3JlZFVzZXJUeXBlIGFzICduZXcnIHwgJ3JldHVybmluZycgfCAnYWN0aXZlJztcbiAgfVxuICBcbiAgLy8gR2V0IGZyb20gY29va2llcyAoaWYgdXNpbmcgYSBjb29raWUgbGlicmFyeSlcbiAgLy8gWW91IGNhbiBhZGQgY29va2llIHBhcnNpbmcgaGVyZSBpZiBuZWVkZWRcbiAgXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIFN0b3JlIHVzZXIgYXR0cmlidXRlcyBpbiBjbGllbnQtc2lkZSBzdG9yYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZVVzZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IFBhcnRpYWw8VXNlckF0dHJpYnV0ZXM+KTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKGF0dHJpYnV0ZXMuY2l0eSkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyQ2l0eScsIGF0dHJpYnV0ZXMuY2l0eSk7XG4gIH1cbiAgXG4gIGlmIChhdHRyaWJ1dGVzLmludGVyZXN0cykge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VySW50ZXJlc3RzJywgSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlcy5pbnRlcmVzdHMpKTtcbiAgfVxuICBcbiAgaWYgKGF0dHJpYnV0ZXMudXNlclR5cGUpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlclR5cGUnLCBhdHRyaWJ1dGVzLnVzZXJUeXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBwZXJzb25hbGl6ZWQgb3Bwb3J0dW5pdGllcyBiYXNlZCBvbiB1c2VyIGF0dHJpYnV0ZXNcbiAqIFRoaXMgY29tYmluZXMgcmVndWxhciBvcHBvcnR1bml0eSBmZXRjaGluZyB3aXRoIHBlcnNvbmFsaXphdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGVyc29uYWxpemVkT3Bwb3J0dW5pdGllcyhcbiAgdXNlckF0dHJpYnV0ZXM/OiBVc2VyQXR0cmlidXRlcyxcbiAgZmlsdGVycz86IHtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICBzdGF0dXM/OiBzdHJpbmdbXTtcbiAgfVxuKSB7XG4gIC8vIEZpcnN0LCBnZXQgcGVyc29uYWxpemVkIGNvbnRlbnQgZm9yIG9wcG9ydHVuaXR5IHJlY29tbWVuZGF0aW9uc1xuICAvLyBUaGVuIGZldGNoIGFjdHVhbCBvcHBvcnR1bml0aWVzIGJhc2VkIG9uIHBlcnNvbmFsaXplZCBwcmVmZXJlbmNlc1xuICBcbiAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyIC0gaW1wbGVtZW50IGJhc2VkIG9uIHlvdXIgUGVyc29uYWxpemUgc2V0dXBcbiAgLy8gWW91IG1pZ2h0IHdhbnQgdG86XG4gIC8vIDEuIEdldCBwZXJzb25hbGl6ZWQgY2F1c2UgcHJlZmVyZW5jZXNcbiAgLy8gMi4gR2V0IHBlcnNvbmFsaXplZCBsb2NhdGlvbiBwcmVmZXJlbmNlc1xuICAvLyAzLiBGZXRjaCBvcHBvcnR1bml0aWVzIG1hdGNoaW5nIHRob3NlIHByZWZlcmVuY2VzXG4gIFxuICByZXR1cm4gW107XG59XG4iXSwibmFtZXMiOlsiZ2V0Q29udGVudHN0YWNrQ29uZmlnIiwiZ2V0QXBpQmFzZVVybCIsImdldFBlcnNvbmFsaXplZENvbnRlbnQiLCJjb250ZW50VHlwZVVpZCIsInVzZXJBdHRyaWJ1dGVzIiwib3B0aW9ucyIsImNvbmZpZyIsImJhc2VVcmwiLCJlbnZpcm9ubWVudCIsImxvY2FsZSIsInBlcnNvbmFsaXplQXBpS2V5IiwicHJvY2VzcyIsImVudiIsIkNPTlRFTlRTVEFDS19QRVJTT05BTElaRV9BUElfS0VZIiwiY29uc29sZSIsIndhcm4iLCJnZXREZWZhdWx0Q29udGVudCIsImVudHJ5VWlkIiwiZW5kcG9pbnQiLCJ1cmwiLCJoZWFkZXJzIiwiYXBpS2V5IiwiZGVsaXZlcnlUb2tlbiIsInNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJ2IiwiYXBwZW5kIiwiU3RyaW5nIiwiZnVsbFVybCIsInRvU3RyaW5nIiwiZGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJuZXh0IiwicmV2YWxpZGF0ZSIsIm9rIiwic3RhdHVzIiwianNvbiIsImVudHJ5IiwiZXJyb3IiLCJFcnJvciIsImdldFVzZXJBdHRyaWJ1dGVzRnJvbUNsaWVudCIsImF0dHJpYnV0ZXMiLCJzdG9yZWRDaXR5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInN0b3JlZEludGVyZXN0cyIsInN0b3JlZFVzZXJUeXBlIiwiY2l0eSIsImludGVyZXN0cyIsIkpTT04iLCJwYXJzZSIsInVzZXJUeXBlIiwic3RvcmVVc2VyQXR0cmlidXRlcyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJnZXRQZXJzb25hbGl6ZWRPcHBvcnR1bml0aWVzIiwiZmlsdGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contentstack/personalize.ts\n"));

/***/ })

});