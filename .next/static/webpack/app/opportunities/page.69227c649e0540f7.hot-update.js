"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/opportunities/page",{

/***/ "(app-pages-browser)/./src/lib/contentstack/personalize.ts":
/*!*********************************************!*\
  !*** ./src/lib/contentstack/personalize.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPersonalizedContent: function() { return /* binding */ getPersonalizedContent; },\n/* harmony export */   getPersonalizedOpportunities: function() { return /* binding */ getPersonalizedOpportunities; },\n/* harmony export */   getUserAttributesFromClient: function() { return /* binding */ getUserAttributesFromClient; },\n/* harmony export */   getUserAttributesFromRegistrations: function() { return /* binding */ getUserAttributesFromRegistrations; },\n/* harmony export */   personalizeOpportunityOrder: function() { return /* binding */ personalizeOpportunityOrder; },\n/* harmony export */   storeUserAttributes: function() { return /* binding */ storeUserAttributes; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(app-pages-browser)/./src/lib/contentstack/config.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Contentstack Personalize Integration\n * \n * Provides utilities for fetching personalized content based on user attributes\n * \n * Setup:\n * 1. Enable Personalize in your Contentstack stack\n * 2. Add CONTENTSTACK_PERSONALIZE_API_KEY to .env.local\n * 3. Create user segments in Contentstack Personalize\n * 4. Add Personalize fields to your content types\n */ \n/**\n * Get personalized content from Contentstack\n * \n * @param contentTypeUid - Content type UID (e.g., 'landing_page')\n * @param userAttributes - User attributes for personalization\n * @param options - Additional options\n * @returns Personalized content entry\n */ async function getPersonalizedContent(contentTypeUid, userAttributes) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const config = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getContentstackConfig)();\n    const baseUrl = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)();\n    const environment = options.environment || config.environment;\n    const locale = options.locale || \"en-us\";\n    // Build Personalize API URL\n    const personalizeApiKey = process.env.CONTENTSTACK_PERSONALIZE_API_KEY;\n    if (!personalizeApiKey) {\n        console.warn(\"CONTENTSTACK_PERSONALIZE_API_KEY not set. Returning default content.\");\n        // Fallback to regular content fetch\n        return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n    }\n    const endpoint = options.entryUid ? \"/content_types/\".concat(contentTypeUid, \"/entries/\").concat(options.entryUid) : \"/content_types/\".concat(contentTypeUid, \"/entries\");\n    const url = \"\".concat(baseUrl, \"/v3\").concat(endpoint, \"?environment=\").concat(environment, \"&locale=\").concat(locale);\n    // Build headers with Personalize API key\n    const headers = {\n        \"api_key\": config.apiKey,\n        \"access_token\": config.deliveryToken,\n        \"personalization_api_key\": personalizeApiKey,\n        \"Content-Type\": \"application/json\"\n    };\n    // Add user attributes as query parameters or headers\n    // Contentstack Personalize accepts user attributes in the request\n    const searchParams = new URLSearchParams();\n    if (userAttributes) {\n        // Add user attributes as query parameters\n        Object.entries(userAttributes).forEach((param)=>{\n            let [key, value] = param;\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    value.forEach((v)=>searchParams.append(\"user_attributes[\".concat(key, \"][]\"), String(v)));\n                } else {\n                    searchParams.append(\"user_attributes[\".concat(key, \"]\"), String(value));\n                }\n            }\n        });\n    }\n    const fullUrl = searchParams.toString() ? \"\".concat(url, \"&\").concat(searchParams.toString()) : url;\n    try {\n        var _data_entries;\n        const response = await fetch(fullUrl, {\n            headers,\n            next: {\n                revalidate: 60\n            }\n        });\n        if (!response.ok) {\n            console.warn(\"Personalize API error: \".concat(response.status, \". Falling back to default content.\"));\n            return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n        }\n        const data = await response.json();\n        return (options.entryUid ? data.entry : (_data_entries = data.entries) === null || _data_entries === void 0 ? void 0 : _data_entries[0]) || data;\n    } catch (error) {\n        console.error(\"Error fetching personalized content:\", error);\n        // Fallback to default content\n        return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n    }\n}\n/**\n * Fallback: Get default (non-personalized) content\n */ async function getDefaultContent(contentTypeUid, entryUid, environment, locale) {\n    var _data_entries;\n    const config = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getContentstackConfig)();\n    const baseUrl = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)();\n    const endpoint = entryUid ? \"/content_types/\".concat(contentTypeUid, \"/entries/\").concat(entryUid) : \"/content_types/\".concat(contentTypeUid, \"/entries\");\n    const url = \"\".concat(baseUrl, \"/v3\").concat(endpoint, \"?environment=\").concat(environment, \"&locale=\").concat(locale);\n    const response = await fetch(url, {\n        headers: {\n            \"api_key\": config.apiKey,\n            \"access_token\": config.deliveryToken\n        },\n        next: {\n            revalidate: 60\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch default content: \".concat(response.status));\n    }\n    const data = await response.json();\n    return (entryUid ? data.entry : (_data_entries = data.entries) === null || _data_entries === void 0 ? void 0 : _data_entries[0]) || data;\n}\n/**\n * Get user attributes from client-side storage (localStorage, cookies, etc.)\n * This is a helper function for client components\n */ function getUserAttributesFromClient() {\n    if (false) {}\n    const attributes = {};\n    // Get from localStorage\n    const storedCity = localStorage.getItem(\"userCity\");\n    const storedInterests = localStorage.getItem(\"userInterests\");\n    const storedUserType = localStorage.getItem(\"userType\");\n    if (storedCity) attributes.city = storedCity;\n    if (storedInterests) {\n        try {\n            attributes.interests = JSON.parse(storedInterests);\n        } catch (e) {\n        // Ignore parse errors\n        }\n    }\n    if (storedUserType) {\n        attributes.userType = storedUserType;\n    }\n    // Get from cookies (if using a cookie library)\n    // You can add cookie parsing here if needed\n    return attributes;\n}\n/**\n * Store user attributes in client-side storage\n */ function storeUserAttributes(attributes) {\n    if (false) {}\n    if (attributes.city) {\n        localStorage.setItem(\"userCity\", attributes.city);\n    }\n    if (attributes.interests) {\n        localStorage.setItem(\"userInterests\", JSON.stringify(attributes.interests));\n    }\n    if (attributes.userType) {\n        localStorage.setItem(\"userType\", attributes.userType);\n    }\n}\n/**\n * Personalize opportunity ordering based on user attributes\n * Priority:\n * 1. Location match (city, state, country)\n * 2. Cause match (causes user has registered for)\n * 3. Default order (date ascending)\n */ function personalizeOpportunityOrder(opportunities, userAttributes) {\n    var _userAttributes_city, _userAttributes_state, _userAttributes_country;\n    if (!userAttributes || opportunities.length === 0) {\n        return opportunities;\n    }\n    const userCity = (_userAttributes_city = userAttributes.city) === null || _userAttributes_city === void 0 ? void 0 : _userAttributes_city.toLowerCase();\n    const userState = (_userAttributes_state = userAttributes.state) === null || _userAttributes_state === void 0 ? void 0 : _userAttributes_state.toLowerCase();\n    const userCountry = (_userAttributes_country = userAttributes.country) === null || _userAttributes_country === void 0 ? void 0 : _userAttributes_country.toLowerCase();\n    const userPreferredCauses = (userAttributes.preferredCauses || userAttributes.interests || []).map((c)=>c.toLowerCase());\n    // Score each opportunity based on relevance\n    const scoredOpportunities = opportunities.map((opp)=>{\n        var _opp_city, _opp_state, _opp_country;\n        let score = 0;\n        // Location scoring (higher priority)\n        if (userCity && ((_opp_city = opp.city) === null || _opp_city === void 0 ? void 0 : _opp_city.toLowerCase()) === userCity) {\n            score += 100; // Exact city match\n        } else if (userState && ((_opp_state = opp.state) === null || _opp_state === void 0 ? void 0 : _opp_state.toLowerCase()) === userState) {\n            score += 50; // State match\n        } else if (userCountry && ((_opp_country = opp.country) === null || _opp_country === void 0 ? void 0 : _opp_country.toLowerCase()) === userCountry) {\n            score += 25; // Country match\n        }\n        // Cause scoring (secondary priority)\n        if (opp.causeSlugs && opp.causeSlugs.length > 0 && userPreferredCauses.length > 0) {\n            const matchingCauses = opp.causeSlugs.filter((causeSlug)=>userPreferredCauses.some((pref)=>causeSlug.toLowerCase().includes(pref) || pref.includes(causeSlug.toLowerCase())));\n            score += matchingCauses.length * 10; // 10 points per matching cause\n        }\n        return {\n            opportunity: opp,\n            score\n        };\n    });\n    // Sort by score (descending), then by date (ascending)\n    scoredOpportunities.sort((a, b)=>{\n        if (b.score !== a.score) {\n            return b.score - a.score; // Higher score first\n        }\n        // If scores are equal, sort by date (earlier dates first)\n        return new Date(a.opportunity.startDate).getTime() - new Date(b.opportunity.startDate).getTime();\n    });\n    return scoredOpportunities.map((item)=>item.opportunity);\n}\n/**\n * Extract user attributes from registrations\n * Gets location and preferred causes from user's registration history\n */ function getUserAttributesFromRegistrations() {\n    if (false) {}\n    try {\n        // Import dynamically to avoid SSR issues\n        const { getRegistrations } = __webpack_require__(/*! @/lib/user */ \"(app-pages-browser)/./src/lib/user/index.ts\");\n        const registrations = getRegistrations();\n        if (registrations.length === 0) {\n            return {};\n        }\n        const attributes = {};\n        // Extract most common location from registrations\n        const locations = registrations.map((r)=>r.opportunityLocation).filter(Boolean);\n        if (locations.length > 0) {\n            // Try to extract city from location string (format: \"City, State, Country\")\n            const mostCommonLocation = locations[0];\n            const parts = mostCommonLocation.split(\",\").map((p)=>p.trim());\n            if (parts.length >= 1) attributes.city = parts[0];\n            if (parts.length >= 2) attributes.state = parts[1];\n            if (parts.length >= 3) attributes.country = parts[2];\n        }\n        // Extract preferred causes from opportunity slugs\n        // Try to get cause slugs from opportunity slugs (format: \"opportunity-slug-cause-slug\")\n        const causeKeywords = new Set();\n        registrations.forEach((reg)=>{\n            // Try to extract cause from opportunity slug\n            const slug = reg.opportunitySlug.toLowerCase();\n            const title = reg.opportunityTitle.toLowerCase();\n            // Common cause slugs\n            const causeSlugs = [\n                \"education\",\n                \"environment\",\n                \"healthcare\",\n                \"health\",\n                \"animal-welfare\",\n                \"animal\",\n                \"community-development\",\n                \"community\",\n                \"hunger-relief\",\n                \"hunger\",\n                \"children\",\n                \"elderly\",\n                \"disability\"\n            ];\n            causeSlugs.forEach((causeSlug)=>{\n                if (slug.includes(causeSlug) || title.includes(causeSlug)) {\n                    // Normalize cause slug\n                    const normalized = causeSlug.replace(/-/g, \"-\");\n                    causeKeywords.add(normalized);\n                }\n            });\n        });\n        const causeArray = Array.from(causeKeywords);\n        if (causeKeywords.length > 0) {\n            attributes.preferredCauses = causeKeywords;\n            attributes.interests = causeKeywords;\n        }\n        // Set user type based on registration count\n        if (registrations.length >= 5) {\n            attributes.userType = \"active\";\n        } else if (registrations.length >= 1) {\n            attributes.userType = \"returning\";\n        }\n        attributes.registrationCount = registrations.length;\n        return attributes;\n    } catch (error) {\n        console.error(\"Error extracting user attributes from registrations:\", error);\n        return {};\n    }\n}\n/**\n * Get personalized opportunities based on user attributes\n * This combines regular opportunity fetching with personalization\n */ async function getPersonalizedOpportunities(userAttributes, filters) {\n    // First, get personalized content for opportunity recommendations\n    // Then fetch actual opportunities based on personalized preferences\n    // This is a placeholder - implement based on your Personalize setup\n    // You might want to:\n    // 1. Get personalized cause preferences\n    // 2. Get personalized location preferences\n    // 3. Fetch opportunities matching those preferences\n    return [];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGVudHN0YWNrL3BlcnNvbmFsaXplLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUUrRDtBQXVDaEU7Ozs7Ozs7Q0FPQyxHQUNNLGVBQWVFLHVCQUNwQkMsY0FBc0IsRUFDdEJDLGNBQStCO1FBQy9CQyxVQUFBQSxpRUFBeUUsQ0FBQztJQUUxRSxNQUFNQyxTQUFTTiw4REFBcUJBO0lBQ3BDLE1BQU1PLFVBQVVOLHNEQUFhQTtJQUM3QixNQUFNTyxjQUFjSCxRQUFRRyxXQUFXLElBQUlGLE9BQU9FLFdBQVc7SUFDN0QsTUFBTUMsU0FBU0osUUFBUUksTUFBTSxJQUFJO0lBRWpDLDRCQUE0QjtJQUM1QixNQUFNQyxvQkFBb0JDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsZ0NBQWdDO0lBRXRFLElBQUksQ0FBQ0gsbUJBQW1CO1FBQ3RCSSxRQUFRQyxJQUFJLENBQUM7UUFDYixvQ0FBb0M7UUFDcEMsT0FBT0Msa0JBQXFCYixnQkFBZ0JFLFFBQVFZLFFBQVEsRUFBRVQsYUFBYUM7SUFDN0U7SUFFQSxNQUFNUyxXQUFXYixRQUFRWSxRQUFRLEdBQzdCLGtCQUE0Q1osT0FBMUJGLGdCQUFlLGFBQTRCLE9BQWpCRSxRQUFRWSxRQUFRLElBQzVELGtCQUFpQyxPQUFmZCxnQkFBZTtJQUVyQyxNQUFNZ0IsTUFBTSxHQUFnQkQsT0FBYlgsU0FBUSxPQUE2QkMsT0FBeEJVLFVBQVMsaUJBQXFDVCxPQUF0QkQsYUFBWSxZQUFpQixPQUFQQztJQUUxRSx5Q0FBeUM7SUFDekMsTUFBTVcsVUFBdUI7UUFDM0IsV0FBV2QsT0FBT2UsTUFBTTtRQUN4QixnQkFBZ0JmLE9BQU9nQixhQUFhO1FBQ3BDLDJCQUEyQlo7UUFDM0IsZ0JBQWdCO0lBQ2xCO0lBRUEscURBQXFEO0lBQ3JELGtFQUFrRTtJQUNsRSxNQUFNYSxlQUFlLElBQUlDO0lBRXpCLElBQUlwQixnQkFBZ0I7UUFDbEIsMENB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O0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxlQUFlMEUsNkJBQ3BCckgsY0FBK0IsRUFDL0JzSCxPQUdDO0lBRUQsa0VBQWtFO0lBQ2xFLG9FQUFvRTtJQUVwRSxvRUFBb0U7SUFDcEUscUJBQXFCO0lBQ3JCLHdDQUF3QztJQUN4QywyQ0FBMkM7SUFDM0Msb0RBQW9EO0lBRXBELE9BQU8sRUFBRTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY29udGVudHN0YWNrL3BlcnNvbmFsaXplLnRzP2ZjNGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250ZW50c3RhY2sgUGVyc29uYWxpemUgSW50ZWdyYXRpb25cbiAqIFxuICogUHJvdmlkZXMgdXRpbGl0aWVzIGZvciBmZXRjaGluZyBwZXJzb25hbGl6ZWQgY29udGVudCBiYXNlZCBvbiB1c2VyIGF0dHJpYnV0ZXNcbiAqIFxuICogU2V0dXA6XG4gKiAxLiBFbmFibGUgUGVyc29uYWxpemUgaW4geW91ciBDb250ZW50c3RhY2sgc3RhY2tcbiAqIDIuIEFkZCBDT05URU5UU1RBQ0tfUEVSU09OQUxJWkVfQVBJX0tFWSB0byAuZW52LmxvY2FsXG4gKiAzLiBDcmVhdGUgdXNlciBzZWdtZW50cyBpbiBDb250ZW50c3RhY2sgUGVyc29uYWxpemVcbiAqIDQuIEFkZCBQZXJzb25hbGl6ZSBmaWVsZHMgdG8geW91ciBjb250ZW50IHR5cGVzXG4gKi9cblxuaW1wb3J0IHsgZ2V0Q29udGVudHN0YWNrQ29uZmlnLCBnZXRBcGlCYXNlVXJsIH0gZnJvbSAnLi9jb25maWcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJBdHRyaWJ1dGVzIHtcbiAgLy8gTG9jYXRpb25cbiAgY2l0eT86IHN0cmluZztcbiAgc3RhdGU/OiBzdHJpbmc7XG4gIGNvdW50cnk/OiBzdHJpbmc7XG4gIFxuICAvLyBJbnRlcmVzdHMgJiBQcmVmZXJlbmNlc1xuICBpbnRlcmVzdHM/OiBzdHJpbmdbXTtcbiAgcHJlZmVycmVkQ2F1c2VzPzogc3RyaW5nW107XG4gIGNvbnRyaWJ1dGlvblR5cGVzPzogc3RyaW5nW107XG4gIFxuICAvLyBVc2VyIEJlaGF2aW9yXG4gIHVzZXJUeXBlPzogJ25ldycgfCAncmV0dXJuaW5nJyB8ICdhY3RpdmUnO1xuICByZWdpc3RyYXRpb25Db3VudD86IG51bWJlcjtcbiAgbGFzdFZpc2l0RGF0ZT86IHN0cmluZztcbiAgXG4gIC8vIERlbW9ncmFwaGljcyAob3B0aW9uYWwpXG4gIGFnZT86IG51bWJlcjtcbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIFxuICAvLyBDdXN0b20gYXR0cmlidXRlc1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZXJzb25hbGl6ZU9wdGlvbnMge1xuICAvKiogVXNlciBhdHRyaWJ1dGVzIGZvciBwZXJzb25hbGl6YXRpb24gKi9cbiAgdXNlckF0dHJpYnV0ZXM/OiBVc2VyQXR0cmlidXRlcztcbiAgLyoqIENvbnRlbnQgdHlwZSBVSUQgKi9cbiAgY29udGVudFR5cGVVaWQ6IHN0cmluZztcbiAgLyoqIEVudHJ5IFVJRCAob3B0aW9uYWwsIGZvciBzcGVjaWZpYyBlbnRyeSkgKi9cbiAgZW50cnlVaWQ/OiBzdHJpbmc7XG4gIC8qKiBFbnZpcm9ubWVudCAoZGVmYXVsdHMgdG8gY29uZmlndXJlZCBlbnZpcm9ubWVudCkgKi9cbiAgZW52aXJvbm1lbnQ/OiBzdHJpbmc7XG4gIC8qKiBMb2NhbGUgKGRlZmF1bHRzIHRvICdlbi11cycpICovXG4gIGxvY2FsZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBHZXQgcGVyc29uYWxpemVkIGNvbnRlbnQgZnJvbSBDb250ZW50c3RhY2tcbiAqIFxuICogQHBhcmFtIGNvbnRlbnRUeXBlVWlkIC0gQ29udGVudCB0eXBlIFVJRCAoZS5nLiwgJ2xhbmRpbmdfcGFnZScpXG4gKiBAcGFyYW0gdXNlckF0dHJpYnV0ZXMgLSBVc2VyIGF0dHJpYnV0ZXMgZm9yIHBlcnNvbmFsaXphdGlvblxuICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm5zIFBlcnNvbmFsaXplZCBjb250ZW50IGVudHJ5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZXJzb25hbGl6ZWRDb250ZW50PFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIGNvbnRlbnRUeXBlVWlkOiBzdHJpbmcsXG4gIHVzZXJBdHRyaWJ1dGVzPzogVXNlckF0dHJpYnV0ZXMsXG4gIG9wdGlvbnM6IE9taXQ8UGVyc29uYWxpemVPcHRpb25zLCAnY29udGVudFR5cGVVaWQnIHwgJ3VzZXJBdHRyaWJ1dGVzJz4gPSB7fVxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldENvbnRlbnRzdGFja0NvbmZpZygpO1xuICBjb25zdCBiYXNlVXJsID0gZ2V0QXBpQmFzZVVybCgpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgY29uZmlnLmVudmlyb25tZW50O1xuICBjb25zdCBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCAnZW4tdXMnO1xuICBcbiAgLy8gQnVpbGQgUGVyc29uYWxpemUgQVBJIFVSTFxuICBjb25zdCBwZXJzb25hbGl6ZUFwaUtleSA9IHByb2Nlc3MuZW52LkNPTlRFTlRTVEFDS19QRVJTT05BTElaRV9BUElfS0VZO1xuICBcbiAgaWYgKCFwZXJzb25hbGl6ZUFwaUtleSkge1xuICAgIGNvbnNvbGUud2FybignQ09OVEVOVFNUQUNLX1BFUlNPTkFMSVpFX0FQSV9LRVkgbm90IHNldC4gUmV0dXJuaW5nIGRlZmF1bHQgY29udGVudC4nKTtcbiAgICAvLyBGYWxsYmFjayB0byByZWd1bGFyIGNvbnRlbnQgZmV0Y2hcbiAgICByZXR1cm4gZ2V0RGVmYXVsdENvbnRlbnQ8VD4oY29udGVudFR5cGVVaWQsIG9wdGlvbnMuZW50cnlVaWQsIGVudmlyb25tZW50LCBsb2NhbGUpO1xuICB9XG4gIFxuICBjb25zdCBlbmRwb2ludCA9IG9wdGlvbnMuZW50cnlVaWRcbiAgICA/IGAvY29udGVudF90eXBlcy8ke2NvbnRlbnRUeXBlVWlkfS9lbnRyaWVzLyR7b3B0aW9ucy5lbnRyeVVpZH1gXG4gICAgOiBgL2NvbnRlbnRfdHlwZXMvJHtjb250ZW50VHlwZVVpZH0vZW50cmllc2A7XG4gIFxuICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS92MyR7ZW5kcG9pbnR9P2Vudmlyb25tZW50PSR7ZW52aXJvbm1lbnR9JmxvY2FsZT0ke2xvY2FsZX1gO1xuICBcbiAgLy8gQnVpbGQgaGVhZGVycyB3aXRoIFBlcnNvbmFsaXplIEFQSSBrZXlcbiAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgJ2FwaV9rZXknOiBjb25maWcuYXBpS2V5LFxuICAgICdhY2Nlc3NfdG9rZW4nOiBjb25maWcuZGVsaXZlcnlUb2tlbixcbiAgICAncGVyc29uYWxpemF0aW9uX2FwaV9rZXknOiBwZXJzb25hbGl6ZUFwaUtleSxcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB9O1xuICBcbiAgLy8gQWRkIHVzZXIgYXR0cmlidXRlcyBhcyBxdWVyeSBwYXJhbWV0ZXJzIG9yIGhlYWRlcnNcbiAgLy8gQ29udGVudHN0YWNrIFBlcnNvbmFsaXplIGFjY2VwdHMgdXNlciBhdHRyaWJ1dGVzIGluIHRoZSByZXF1ZXN0XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgXG4gIGlmICh1c2VyQXR0cmlidXRlcykge1xuICAgIC8vIEFkZCB1c2VyIGF0dHJpYnV0ZXMgYXMgcXVlcnkgcGFyYW1ldGVyc1xuICAgIE9iamVjdC5lbnRyaWVzKHVzZXJBdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlLmZvckVhY2godiA9PiBzZWFyY2hQYXJhbXMuYXBwZW5kKGB1c2VyX2F0dHJpYnV0ZXNbJHtrZXl9XVtdYCwgU3RyaW5nKHYpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChgdXNlcl9hdHRyaWJ1dGVzWyR7a2V5fV1gLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIFxuICBjb25zdCBmdWxsVXJsID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCkgPyBgJHt1cmx9JiR7c2VhcmNoUGFyYW1zLnRvU3RyaW5nKCl9YCA6IHVybDtcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgbmV4dDogeyByZXZhbGlkYXRlOiA2MCB9LCAvLyBDYWNoZSBmb3IgNjAgc2Vjb25kc1xuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnNvbGUud2FybihgUGVyc29uYWxpemUgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30uIEZhbGxpbmcgYmFjayB0byBkZWZhdWx0IGNvbnRlbnQuYCk7XG4gICAgICByZXR1cm4gZ2V0RGVmYXVsdENvbnRlbnQ8VD4oY29udGVudFR5cGVVaWQsIG9wdGlvbnMuZW50cnlVaWQsIGVudmlyb25tZW50LCBsb2NhbGUpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiAob3B0aW9ucy5lbnRyeVVpZCA/IGRhdGEuZW50cnkgOiBkYXRhLmVudHJpZXM/LlswXSkgfHwgZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwZXJzb25hbGl6ZWQgY29udGVudDonLCBlcnJvcik7XG4gICAgLy8gRmFsbGJhY2sgdG8gZGVmYXVsdCBjb250ZW50XG4gICAgcmV0dXJuIGdldERlZmF1bHRDb250ZW50PFQ+KGNvbnRlbnRUeXBlVWlkLCBvcHRpb25zLmVudHJ5VWlkLCBlbnZpcm9ubWVudCwgbG9jYWxlKTtcbiAgfVxufVxuXG4vKipcbiAqIEZhbGxiYWNrOiBHZXQgZGVmYXVsdCAobm9uLXBlcnNvbmFsaXplZCkgY29udGVudFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0Q29udGVudDxUPihcbiAgY29udGVudFR5cGVVaWQ6IHN0cmluZyxcbiAgZW50cnlVaWQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZW52aXJvbm1lbnQ6IHN0cmluZyxcbiAgbG9jYWxlOiBzdHJpbmdcbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBjb25maWcgPSBnZXRDb250ZW50c3RhY2tDb25maWcoKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEFwaUJhc2VVcmwoKTtcbiAgXG4gIGNvbnN0IGVuZHBvaW50ID0gZW50cnlVaWRcbiAgICA/IGAvY29udGVudF90eXBlcy8ke2NvbnRlbnRUeXBlVWlkfS9lbnRyaWVzLyR7ZW50cnlVaWR9YFxuICAgIDogYC9jb250ZW50X3R5cGVzLyR7Y29udGVudFR5cGVVaWR9L2VudHJpZXNgO1xuICBcbiAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0vdjMke2VuZHBvaW50fT9lbnZpcm9ubWVudD0ke2Vudmlyb25tZW50fSZsb2NhbGU9JHtsb2NhbGV9YDtcbiAgXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgJ2FwaV9rZXknOiBjb25maWcuYXBpS2V5LFxuICAgICAgJ2FjY2Vzc190b2tlbic6IGNvbmZpZy5kZWxpdmVyeVRva2VuLFxuICAgIH0sXG4gICAgbmV4dDogeyByZXZhbGlkYXRlOiA2MCB9LFxuICB9KTtcbiAgXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBkZWZhdWx0IGNvbnRlbnQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICB9XG4gIFxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICByZXR1cm4gKGVudHJ5VWlkID8gZGF0YS5lbnRyeSA6IGRhdGEuZW50cmllcz8uWzBdKSB8fCBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB1c2VyIGF0dHJpYnV0ZXMgZnJvbSBjbGllbnQtc2lkZSBzdG9yYWdlIChsb2NhbFN0b3JhZ2UsIGNvb2tpZXMsIGV0Yy4pXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBjbGllbnQgY29tcG9uZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckF0dHJpYnV0ZXNGcm9tQ2xpZW50KCk6IFVzZXJBdHRyaWJ1dGVzIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIFxuICBjb25zdCBhdHRyaWJ1dGVzOiBVc2VyQXR0cmlidXRlcyA9IHt9O1xuICBcbiAgLy8gR2V0IGZyb20gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IHN0b3JlZENpdHkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlckNpdHknKTtcbiAgY29uc3Qgc3RvcmVkSW50ZXJlc3RzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJJbnRlcmVzdHMnKTtcbiAgY29uc3Qgc3RvcmVkVXNlclR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlclR5cGUnKTtcbiAgXG4gIGlmIChzdG9yZWRDaXR5KSBhdHRyaWJ1dGVzLmNpdHkgPSBzdG9yZWRDaXR5O1xuICBpZiAoc3RvcmVkSW50ZXJlc3RzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF0dHJpYnV0ZXMuaW50ZXJlc3RzID0gSlNPTi5wYXJzZShzdG9yZWRJbnRlcmVzdHMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIHBhcnNlIGVycm9yc1xuICAgIH1cbiAgfVxuICBpZiAoc3RvcmVkVXNlclR5cGUpIHtcbiAgICBhdHRyaWJ1dGVzLnVzZXJUeXBlID0gc3RvcmVkVXNlclR5cGUgYXMgJ25ldycgfCAncmV0dXJuaW5nJyB8ICdhY3RpdmUnO1xuICB9XG4gIFxuICAvLyBHZXQgZnJvbSBjb29raWVzIChpZiB1c2luZyBhIGNvb2tpZSBsaWJyYXJ5KVxuICAvLyBZb3UgY2FuIGFkZCBjb29raWUgcGFyc2luZyBoZXJlIGlmIG5lZWRlZFxuICBcbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbi8qKlxuICogU3RvcmUgdXNlciBhdHRyaWJ1dGVzIGluIGNsaWVudC1zaWRlIHN0b3JhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlVXNlckF0dHJpYnV0ZXMoYXR0cmlidXRlczogUGFydGlhbDxVc2VyQXR0cmlidXRlcz4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICBpZiAoYXR0cmlidXRlcy5jaXR5KSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJDaXR5JywgYXR0cmlidXRlcy5jaXR5KTtcbiAgfVxuICBcbiAgaWYgKGF0dHJpYnV0ZXMuaW50ZXJlc3RzKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJJbnRlcmVzdHMnLCBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVzLmludGVyZXN0cykpO1xuICB9XG4gIFxuICBpZiAoYXR0cmlidXRlcy51c2VyVHlwZSkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyVHlwZScsIGF0dHJpYnV0ZXMudXNlclR5cGUpO1xuICB9XG59XG5cbi8qKlxuICogUGVyc29uYWxpemUgb3Bwb3J0dW5pdHkgb3JkZXJpbmcgYmFzZWQgb24gdXNlciBhdHRyaWJ1dGVzXG4gKiBQcmlvcml0eTpcbiAqIDEuIExvY2F0aW9uIG1hdGNoIChjaXR5LCBzdGF0ZSwgY291bnRyeSlcbiAqIDIuIENhdXNlIG1hdGNoIChjYXVzZXMgdXNlciBoYXMgcmVnaXN0ZXJlZCBmb3IpXG4gKiAzLiBEZWZhdWx0IG9yZGVyIChkYXRlIGFzY2VuZGluZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcnNvbmFsaXplT3Bwb3J0dW5pdHlPcmRlcjxUIGV4dGVuZHMge1xuICBjaXR5Pzogc3RyaW5nO1xuICBzdGF0ZT86IHN0cmluZztcbiAgY291bnRyeT86IHN0cmluZztcbiAgY2F1c2VTbHVncz86IHN0cmluZ1tdO1xuICBzdGFydERhdGU6IHN0cmluZztcbn0+KFxuICBvcHBvcnR1bml0aWVzOiBUW10sXG4gIHVzZXJBdHRyaWJ1dGVzPzogVXNlckF0dHJpYnV0ZXNcbik6IFRbXSB7XG4gIGlmICghdXNlckF0dHJpYnV0ZXMgfHwgb3Bwb3J0dW5pdGllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb3Bwb3J0dW5pdGllcztcbiAgfVxuXG4gIGNvbnN0IHVzZXJDaXR5ID0gdXNlckF0dHJpYnV0ZXMuY2l0eT8udG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgdXNlclN0YXRlID0gdXNlckF0dHJpYnV0ZXMuc3RhdGU/LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHVzZXJDb3VudHJ5ID0gdXNlckF0dHJpYnV0ZXMuY291bnRyeT8udG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgdXNlclByZWZlcnJlZENhdXNlcyA9ICh1c2VyQXR0cmlidXRlcy5wcmVmZXJyZWRDYXVzZXMgfHwgdXNlckF0dHJpYnV0ZXMuaW50ZXJlc3RzIHx8IFtdKVxuICAgIC5tYXAoYyA9PiBjLnRvTG93ZXJDYXNlKCkpO1xuXG4gIC8vIFNjb3JlIGVhY2ggb3Bwb3J0dW5pdHkgYmFzZWQgb24gcmVsZXZhbmNlXG4gIGNvbnN0IHNjb3JlZE9wcG9ydHVuaXRpZXMgPSBvcHBvcnR1bml0aWVzLm1hcChvcHAgPT4ge1xuICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAvLyBMb2NhdGlvbiBzY29yaW5nIChoaWdoZXIgcHJpb3JpdHkpXG4gICAgaWYgKHVzZXJDaXR5ICYmIG9wcC5jaXR5Py50b0xvd2VyQ2FzZSgpID09PSB1c2VyQ2l0eSkge1xuICAgICAgc2NvcmUgKz0gMTAwOyAvLyBFeGFjdCBjaXR5IG1hdGNoXG4gICAgfSBlbHNlIGlmICh1c2VyU3RhdGUgJiYgb3BwLnN0YXRlPy50b0xvd2VyQ2FzZSgpID09PSB1c2VyU3RhdGUpIHtcbiAgICAgIHNjb3JlICs9IDUwOyAvLyBTdGF0ZSBtYXRjaFxuICAgIH0gZWxzZSBpZiAodXNlckNvdW50cnkgJiYgb3BwLmNvdW50cnk/LnRvTG93ZXJDYXNlKCkgPT09IHVzZXJDb3VudHJ5KSB7XG4gICAgICBzY29yZSArPSAyNTsgLy8gQ291bnRyeSBtYXRjaFxuICAgIH1cblxuICAgIC8vIENhdXNlIHNjb3JpbmcgKHNlY29uZGFyeSBwcmlvcml0eSlcbiAgICBpZiAob3BwLmNhdXNlU2x1Z3MgJiYgb3BwLmNhdXNlU2x1Z3MubGVuZ3RoID4gMCAmJiB1c2VyUHJlZmVycmVkQ2F1c2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nQ2F1c2VzID0gb3BwLmNhdXNlU2x1Z3MuZmlsdGVyKGNhdXNlU2x1ZyA9PlxuICAgICAgICB1c2VyUHJlZmVycmVkQ2F1c2VzLnNvbWUocHJlZiA9PiBcbiAgICAgICAgICBjYXVzZVNsdWcudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwcmVmKSB8fCBcbiAgICAgICAgICBwcmVmLmluY2x1ZGVzKGNhdXNlU2x1Zy50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc2NvcmUgKz0gbWF0Y2hpbmdDYXVzZXMubGVuZ3RoICogMTA7IC8vIDEwIHBvaW50cyBwZXIgbWF0Y2hpbmcgY2F1c2VcbiAgICB9XG5cbiAgICByZXR1cm4geyBvcHBvcnR1bml0eTogb3BwLCBzY29yZSB9O1xuICB9KTtcblxuICAvLyBTb3J0IGJ5IHNjb3JlIChkZXNjZW5kaW5nKSwgdGhlbiBieSBkYXRlIChhc2NlbmRpbmcpXG4gIHNjb3JlZE9wcG9ydHVuaXRpZXMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChiLnNjb3JlICE9PSBhLnNjb3JlKSB7XG4gICAgICByZXR1cm4gYi5zY29yZSAtIGEuc2NvcmU7IC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICAgIH1cbiAgICAvLyBJZiBzY29yZXMgYXJlIGVxdWFsLCBzb3J0IGJ5IGRhdGUgKGVhcmxpZXIgZGF0ZXMgZmlyc3QpXG4gICAgcmV0dXJuIG5ldyBEYXRlKGEub3Bwb3J0dW5pdHkuc3RhcnREYXRlKS5nZXRUaW1lKCkgLSBcbiAgICAgICAgICAgbmV3IERhdGUoYi5vcHBvcnR1bml0eS5zdGFydERhdGUpLmdldFRpbWUoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNjb3JlZE9wcG9ydHVuaXRpZXMubWFwKGl0ZW0gPT4gaXRlbS5vcHBvcnR1bml0eSk7XG59XG5cbi8qKlxuICogRXh0cmFjdCB1c2VyIGF0dHJpYnV0ZXMgZnJvbSByZWdpc3RyYXRpb25zXG4gKiBHZXRzIGxvY2F0aW9uIGFuZCBwcmVmZXJyZWQgY2F1c2VzIGZyb20gdXNlcidzIHJlZ2lzdHJhdGlvbiBoaXN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQXR0cmlidXRlc0Zyb21SZWdpc3RyYXRpb25zKCk6IFVzZXJBdHRyaWJ1dGVzIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBJbXBvcnQgZHluYW1pY2FsbHkgdG8gYXZvaWQgU1NSIGlzc3Vlc1xuICAgIGNvbnN0IHsgZ2V0UmVnaXN0cmF0aW9ucyB9ID0gcmVxdWlyZSgnQC9saWIvdXNlcicpO1xuICAgIGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBnZXRSZWdpc3RyYXRpb25zKCk7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzOiBVc2VyQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCBtb3N0IGNvbW1vbiBsb2NhdGlvbiBmcm9tIHJlZ2lzdHJhdGlvbnNcbiAgICBjb25zdCBsb2NhdGlvbnMgPSByZWdpc3RyYXRpb25zXG4gICAgICAubWFwKHIgPT4gci5vcHBvcnR1bml0eUxvY2F0aW9uKVxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICBcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFRyeSB0byBleHRyYWN0IGNpdHkgZnJvbSBsb2NhdGlvbiBzdHJpbmcgKGZvcm1hdDogXCJDaXR5LCBTdGF0ZSwgQ291bnRyeVwiKVxuICAgICAgY29uc3QgbW9zdENvbW1vbkxvY2F0aW9uID0gbG9jYXRpb25zWzBdO1xuICAgICAgY29uc3QgcGFydHMgPSBtb3N0Q29tbW9uTG9jYXRpb24uc3BsaXQoJywnKS5tYXAocCA9PiBwLnRyaW0oKSk7XG4gICAgICBcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMSkgYXR0cmlidXRlcy5jaXR5ID0gcGFydHNbMF07XG4gICAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIGF0dHJpYnV0ZXMuc3RhdGUgPSBwYXJ0c1sxXTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMykgYXR0cmlidXRlcy5jb3VudHJ5ID0gcGFydHNbMl07XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBwcmVmZXJyZWQgY2F1c2VzIGZyb20gb3Bwb3J0dW5pdHkgc2x1Z3NcbiAgICAvLyBUcnkgdG8gZ2V0IGNhdXNlIHNsdWdzIGZyb20gb3Bwb3J0dW5pdHkgc2x1Z3MgKGZvcm1hdDogXCJvcHBvcnR1bml0eS1zbHVnLWNhdXNlLXNsdWdcIilcbiAgICBjb25zdCBjYXVzZUtleXdvcmRzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgICBcbiAgICByZWdpc3RyYXRpb25zLmZvckVhY2gocmVnID0+IHtcbiAgICAgIC8vIFRyeSB0byBleHRyYWN0IGNhdXNlIGZyb20gb3Bwb3J0dW5pdHkgc2x1Z1xuICAgICAgY29uc3Qgc2x1ZyA9IHJlZy5vcHBvcnR1bml0eVNsdWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHRpdGxlID0gcmVnLm9wcG9ydHVuaXR5VGl0bGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIFxuICAgICAgLy8gQ29tbW9uIGNhdXNlIHNsdWdzXG4gICAgICBjb25zdCBjYXVzZVNsdWdzID0gW1xuICAgICAgICAnZWR1Y2F0aW9uJywgJ2Vudmlyb25tZW50JywgJ2hlYWx0aGNhcmUnLCAnaGVhbHRoJywgXG4gICAgICAgICdhbmltYWwtd2VsZmFyZScsICdhbmltYWwnLCAnY29tbXVuaXR5LWRldmVsb3BtZW50JywgJ2NvbW11bml0eScsXG4gICAgICAgICdodW5nZXItcmVsaWVmJywgJ2h1bmdlcicsICdjaGlsZHJlbicsICdlbGRlcmx5JywgJ2Rpc2FiaWxpdHknXG4gICAgICBdO1xuICAgICAgXG4gICAgICBjYXVzZVNsdWdzLmZvckVhY2goY2F1c2VTbHVnID0+IHtcbiAgICAgICAgaWYgKHNsdWcuaW5jbHVkZXMoY2F1c2VTbHVnKSB8fCB0aXRsZS5pbmNsdWRlcyhjYXVzZVNsdWcpKSB7XG4gICAgICAgICAgLy8gTm9ybWFsaXplIGNhdXNlIHNsdWdcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gY2F1c2VTbHVnLnJlcGxhY2UoLy0vZywgJy0nKTtcbiAgICAgICAgICBjYXVzZUtleXdvcmRzLmFkZChub3JtYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBjYXVzZUFycmF5ID0gQXJyYXkuZnJvbShjYXVzZUtleXdvcmRzKTtcblxuICAgIGlmIChjYXVzZUtleXdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXMucHJlZmVycmVkQ2F1c2VzID0gY2F1c2VLZXl3b3JkcztcbiAgICAgIGF0dHJpYnV0ZXMuaW50ZXJlc3RzID0gY2F1c2VLZXl3b3JkcztcbiAgICB9XG5cbiAgICAvLyBTZXQgdXNlciB0eXBlIGJhc2VkIG9uIHJlZ2lzdHJhdGlvbiBjb3VudFxuICAgIGlmIChyZWdpc3RyYXRpb25zLmxlbmd0aCA+PSA1KSB7XG4gICAgICBhdHRyaWJ1dGVzLnVzZXJUeXBlID0gJ2FjdGl2ZSc7XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBhdHRyaWJ1dGVzLnVzZXJUeXBlID0gJ3JldHVybmluZyc7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcy5yZWdpc3RyYXRpb25Db3VudCA9IHJlZ2lzdHJhdGlvbnMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZXh0cmFjdGluZyB1c2VyIGF0dHJpYnV0ZXMgZnJvbSByZWdpc3RyYXRpb25zOicsIGVycm9yKTtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgcGVyc29uYWxpemVkIG9wcG9ydHVuaXRpZXMgYmFzZWQgb24gdXNlciBhdHRyaWJ1dGVzXG4gKiBUaGlzIGNvbWJpbmVzIHJlZ3VsYXIgb3Bwb3J0dW5pdHkgZmV0Y2hpbmcgd2l0aCBwZXJzb25hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlcnNvbmFsaXplZE9wcG9ydHVuaXRpZXMoXG4gIHVzZXJBdHRyaWJ1dGVzPzogVXNlckF0dHJpYnV0ZXMsXG4gIGZpbHRlcnM/OiB7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gICAgc3RhdHVzPzogc3RyaW5nW107XG4gIH1cbikge1xuICAvLyBGaXJzdCwgZ2V0IHBlcnNvbmFsaXplZCBjb250ZW50IGZvciBvcHBvcnR1bml0eSByZWNvbW1lbmRhdGlvbnNcbiAgLy8gVGhlbiBmZXRjaCBhY3R1YWwgb3Bwb3J0dW5pdGllcyBiYXNlZCBvbiBwZXJzb25hbGl6ZWQgcHJlZmVyZW5jZXNcbiAgXG4gIC8vIFRoaXMgaXMgYSBwbGFjZWhvbGRlciAtIGltcGxlbWVudCBiYXNlZCBvbiB5b3VyIFBlcnNvbmFsaXplIHNldHVwXG4gIC8vIFlvdSBtaWdodCB3YW50IHRvOlxuICAvLyAxLiBHZXQgcGVyc29uYWxpemVkIGNhdXNlIHByZWZlcmVuY2VzXG4gIC8vIDIuIEdldCBwZXJzb25hbGl6ZWQgbG9jYXRpb24gcHJlZmVyZW5jZXNcbiAgLy8gMy4gRmV0Y2ggb3Bwb3J0dW5pdGllcyBtYXRjaGluZyB0aG9zZSBwcmVmZXJlbmNlc1xuICBcbiAgcmV0dXJuIFtdO1xufVxuIl0sIm5hbWVzIjpbImdldENvbnRlbnRzdGFja0NvbmZpZyIsImdldEFwaUJhc2VVcmwiLCJnZXRQZXJzb25hbGl6ZWRDb250ZW50IiwiY29udGVudFR5cGVVaWQiLCJ1c2VyQXR0cmlidXRlcyIsIm9wdGlvbnMiLCJjb25maWciLCJiYXNlVXJsIiwiZW52aXJvbm1lbnQiLCJsb2NhbGUiLCJwZXJzb25hbGl6ZUFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJDT05URU5UU1RBQ0tfUEVSU09OQUxJWkVfQVBJX0tFWSIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0RGVmYXVsdENvbnRlbnQiLCJlbnRyeVVpZCIsImVuZHBvaW50IiwidXJsIiwiaGVhZGVycyIsImFwaUtleSIsImRlbGl2ZXJ5VG9rZW4iLCJzZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsImFwcGVuZCIsIlN0cmluZyIsImZ1bGxVcmwiLCJ0b1N0cmluZyIsImRhdGEiLCJyZXNwb25zZSIsImZldGNoIiwibmV4dCIsInJldmFsaWRhdGUiLCJvayIsInN0YXR1cyIsImpzb24iLCJlbnRyeSIsImVycm9yIiwiRXJyb3IiLCJnZXRVc2VyQXR0cmlidXRlc0Zyb21DbGllbnQiLCJhdHRyaWJ1dGVzIiwic3RvcmVkQ2l0eSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzdG9yZWRJbnRlcmVzdHMiLCJzdG9yZWRVc2VyVHlwZSIsImNpdHkiLCJpbnRlcmVzdHMiLCJKU09OIiwicGFyc2UiLCJ1c2VyVHlwZSIsInN0b3JlVXNlckF0dHJpYnV0ZXMiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwicGVyc29uYWxpemVPcHBvcnR1bml0eU9yZGVyIiwib3Bwb3J0dW5pdGllcyIsImxlbmd0aCIsInVzZXJDaXR5IiwidG9Mb3dlckNhc2UiLCJ1c2VyU3RhdGUiLCJzdGF0ZSIsInVzZXJDb3VudHJ5IiwiY291bnRyeSIsInVzZXJQcmVmZXJyZWRDYXVzZXMiLCJwcmVmZXJyZWRDYXVzZXMiLCJtYXAiLCJjIiwic2NvcmVkT3Bwb3J0dW5pdGllcyIsIm9wcCIsInNjb3JlIiwiY2F1c2VTbHVncyIsIm1hdGNoaW5nQ2F1c2VzIiwiZmlsdGVyIiwiY2F1c2VTbHVnIiwic29tZSIsInByZWYiLCJpbmNsdWRlcyIsIm9wcG9ydHVuaXR5Iiwic29ydCIsImEiLCJiIiwiRGF0ZSIsInN0YXJ0RGF0ZSIsImdldFRpbWUiLCJpdGVtIiwiZ2V0VXNlckF0dHJpYnV0ZXNGcm9tUmVnaXN0cmF0aW9ucyIsImdldFJlZ2lzdHJhdGlvbnMiLCJyZXF1aXJlIiwicmVnaXN0cmF0aW9ucyIsImxvY2F0aW9ucyIsInIiLCJvcHBvcnR1bml0eUxvY2F0aW9uIiwiQm9vbGVhbiIsIm1vc3RDb21tb25Mb2NhdGlvbiIsInBhcnRzIiwic3BsaXQiLCJwIiwidHJpbSIsImNhdXNlS2V5d29yZHMiLCJTZXQiLCJyZWciLCJzbHVnIiwib3Bwb3J0dW5pdHlTbHVnIiwidGl0bGUiLCJvcHBvcnR1bml0eVRpdGxlIiwibm9ybWFsaXplZCIsInJlcGxhY2UiLCJhZGQiLCJjYXVzZUFycmF5IiwiZnJvbSIsInJlZ2lzdHJhdGlvbkNvdW50IiwiZ2V0UGVyc29uYWxpemVkT3Bwb3J0dW5pdGllcyIsImZpbHRlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contentstack/personalize.ts\n"));

/***/ })

});