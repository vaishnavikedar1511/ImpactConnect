"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/opportunities/page",{

/***/ "(app-pages-browser)/./src/lib/contentstack/personalize.ts":
/*!*********************************************!*\
  !*** ./src/lib/contentstack/personalize.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPersonalizedContent: function() { return /* binding */ getPersonalizedContent; },\n/* harmony export */   getPersonalizedOpportunities: function() { return /* binding */ getPersonalizedOpportunities; },\n/* harmony export */   getUserAttributesFromClient: function() { return /* binding */ getUserAttributesFromClient; },\n/* harmony export */   getUserAttributesFromRegistrations: function() { return /* binding */ getUserAttributesFromRegistrations; },\n/* harmony export */   personalizeOpportunityOrder: function() { return /* binding */ personalizeOpportunityOrder; },\n/* harmony export */   storeUserAttributes: function() { return /* binding */ storeUserAttributes; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(app-pages-browser)/./src/lib/contentstack/config.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Contentstack Personalize Integration\n * \n * Provides utilities for fetching personalized content based on user attributes\n * \n * Setup:\n * 1. Enable Personalize in your Contentstack stack\n * 2. Add CONTENTSTACK_PERSONALIZE_API_KEY to .env.local\n * 3. Create user segments in Contentstack Personalize\n * 4. Add Personalize fields to your content types\n */ \n/**\n * Get personalized content from Contentstack\n * \n * @param contentTypeUid - Content type UID (e.g., 'landing_page')\n * @param userAttributes - User attributes for personalization\n * @param options - Additional options\n * @returns Personalized content entry\n */ async function getPersonalizedContent(contentTypeUid, userAttributes) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const config = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getContentstackConfig)();\n    const baseUrl = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)();\n    const environment = options.environment || config.environment;\n    const locale = options.locale || \"en-us\";\n    // Build Personalize API URL\n    const personalizeApiKey = process.env.CONTENTSTACK_PERSONALIZE_API_KEY;\n    if (!personalizeApiKey) {\n        console.warn(\"CONTENTSTACK_PERSONALIZE_API_KEY not set. Returning default content.\");\n        // Fallback to regular content fetch\n        return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n    }\n    const endpoint = options.entryUid ? \"/content_types/\".concat(contentTypeUid, \"/entries/\").concat(options.entryUid) : \"/content_types/\".concat(contentTypeUid, \"/entries\");\n    const url = \"\".concat(baseUrl, \"/v3\").concat(endpoint, \"?environment=\").concat(environment, \"&locale=\").concat(locale);\n    // Build headers with Personalize API key\n    const headers = {\n        \"api_key\": config.apiKey,\n        \"access_token\": config.deliveryToken,\n        \"personalization_api_key\": personalizeApiKey,\n        \"Content-Type\": \"application/json\"\n    };\n    // Add user attributes as query parameters or headers\n    // Contentstack Personalize accepts user attributes in the request\n    const searchParams = new URLSearchParams();\n    if (userAttributes) {\n        // Add user attributes as query parameters\n        Object.entries(userAttributes).forEach((param)=>{\n            let [key, value] = param;\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    value.forEach((v)=>searchParams.append(\"user_attributes[\".concat(key, \"][]\"), String(v)));\n                } else {\n                    searchParams.append(\"user_attributes[\".concat(key, \"]\"), String(value));\n                }\n            }\n        });\n    }\n    const fullUrl = searchParams.toString() ? \"\".concat(url, \"&\").concat(searchParams.toString()) : url;\n    try {\n        var _data_entries;\n        const response = await fetch(fullUrl, {\n            headers,\n            next: {\n                revalidate: 60\n            }\n        });\n        if (!response.ok) {\n            console.warn(\"Personalize API error: \".concat(response.status, \". Falling back to default content.\"));\n            return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n        }\n        const data = await response.json();\n        return (options.entryUid ? data.entry : (_data_entries = data.entries) === null || _data_entries === void 0 ? void 0 : _data_entries[0]) || data;\n    } catch (error) {\n        console.error(\"Error fetching personalized content:\", error);\n        // Fallback to default content\n        return getDefaultContent(contentTypeUid, options.entryUid, environment, locale);\n    }\n}\n/**\n * Fallback: Get default (non-personalized) content\n */ async function getDefaultContent(contentTypeUid, entryUid, environment, locale) {\n    var _data_entries;\n    const config = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getContentstackConfig)();\n    const baseUrl = (0,_config__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)();\n    const endpoint = entryUid ? \"/content_types/\".concat(contentTypeUid, \"/entries/\").concat(entryUid) : \"/content_types/\".concat(contentTypeUid, \"/entries\");\n    const url = \"\".concat(baseUrl, \"/v3\").concat(endpoint, \"?environment=\").concat(environment, \"&locale=\").concat(locale);\n    const response = await fetch(url, {\n        headers: {\n            \"api_key\": config.apiKey,\n            \"access_token\": config.deliveryToken\n        },\n        next: {\n            revalidate: 60\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch default content: \".concat(response.status));\n    }\n    const data = await response.json();\n    return (entryUid ? data.entry : (_data_entries = data.entries) === null || _data_entries === void 0 ? void 0 : _data_entries[0]) || data;\n}\n/**\n * Get user attributes from client-side storage (localStorage, cookies, etc.)\n * This is a helper function for client components\n */ function getUserAttributesFromClient() {\n    if (false) {}\n    const attributes = {};\n    // Get from localStorage\n    const storedCity = localStorage.getItem(\"userCity\");\n    const storedInterests = localStorage.getItem(\"userInterests\");\n    const storedUserType = localStorage.getItem(\"userType\");\n    if (storedCity) attributes.city = storedCity;\n    if (storedInterests) {\n        try {\n            attributes.interests = JSON.parse(storedInterests);\n        } catch (e) {\n        // Ignore parse errors\n        }\n    }\n    if (storedUserType) {\n        attributes.userType = storedUserType;\n    }\n    // Get from cookies (if using a cookie library)\n    // You can add cookie parsing here if needed\n    return attributes;\n}\n/**\n * Store user attributes in client-side storage\n */ function storeUserAttributes(attributes) {\n    if (false) {}\n    if (attributes.city) {\n        localStorage.setItem(\"userCity\", attributes.city);\n    }\n    if (attributes.interests) {\n        localStorage.setItem(\"userInterests\", JSON.stringify(attributes.interests));\n    }\n    if (attributes.userType) {\n        localStorage.setItem(\"userType\", attributes.userType);\n    }\n}\n/**\n * Personalize opportunity ordering based on user attributes\n * Priority:\n * 1. Location match (city, state, country)\n * 2. Cause match (causes user has registered for)\n * 3. Default order (date ascending)\n */ function personalizeOpportunityOrder(opportunities, userAttributes) {\n    var _userAttributes_city, _userAttributes_state, _userAttributes_country;\n    if (!userAttributes || opportunities.length === 0) {\n        return opportunities;\n    }\n    const userCity = (_userAttributes_city = userAttributes.city) === null || _userAttributes_city === void 0 ? void 0 : _userAttributes_city.toLowerCase();\n    const userState = (_userAttributes_state = userAttributes.state) === null || _userAttributes_state === void 0 ? void 0 : _userAttributes_state.toLowerCase();\n    const userCountry = (_userAttributes_country = userAttributes.country) === null || _userAttributes_country === void 0 ? void 0 : _userAttributes_country.toLowerCase();\n    const userPreferredCauses = (userAttributes.preferredCauses || userAttributes.interests || []).map((c)=>c.toLowerCase());\n    // Score each opportunity based on relevance\n    const scoredOpportunities = opportunities.map((opp)=>{\n        var _opp_city, _opp_state, _opp_country;\n        let score = 0;\n        // Location scoring (higher priority)\n        if (userCity && ((_opp_city = opp.city) === null || _opp_city === void 0 ? void 0 : _opp_city.toLowerCase()) === userCity) {\n            score += 100; // Exact city match\n        } else if (userState && ((_opp_state = opp.state) === null || _opp_state === void 0 ? void 0 : _opp_state.toLowerCase()) === userState) {\n            score += 50; // State match\n        } else if (userCountry && ((_opp_country = opp.country) === null || _opp_country === void 0 ? void 0 : _opp_country.toLowerCase()) === userCountry) {\n            score += 25; // Country match\n        }\n        // Cause scoring (secondary priority)\n        if (opp.causeSlugs && opp.causeSlugs.length > 0 && userPreferredCauses.length > 0) {\n            const matchingCauses = opp.causeSlugs.filter((causeSlug)=>userPreferredCauses.some((pref)=>causeSlug.toLowerCase().includes(pref) || pref.includes(causeSlug.toLowerCase())));\n            score += matchingCauses.length * 10; // 10 points per matching cause\n        }\n        return {\n            opportunity: opp,\n            score\n        };\n    });\n    // Sort by score (descending), then by date (ascending)\n    scoredOpportunities.sort((a, b)=>{\n        if (b.score !== a.score) {\n            return b.score - a.score; // Higher score first\n        }\n        // If scores are equal, sort by date (earlier dates first)\n        return new Date(a.opportunity.startDate).getTime() - new Date(b.opportunity.startDate).getTime();\n    });\n    return scoredOpportunities.map((item)=>item.opportunity);\n}\n/**\n * Extract user attributes from registrations\n * Gets location and preferred causes from user's registration history\n */ function getUserAttributesFromRegistrations() {\n    if (false) {}\n    try {\n        // Import dynamically to avoid SSR issues\n        const { getRegistrations } = __webpack_require__(/*! @/lib/user */ \"(app-pages-browser)/./src/lib/user/index.ts\");\n        const registrations = getRegistrations();\n        if (registrations.length === 0) {\n            return {};\n        }\n        const attributes = {};\n        // Extract most common location from registrations\n        const locations = registrations.map((r)=>r.opportunityLocation).filter(Boolean);\n        if (locations.length > 0) {\n            // Try to extract city from location string (format: \"City, State, Country\")\n            const mostCommonLocation = locations[0];\n            const parts = mostCommonLocation.split(\",\").map((p)=>p.trim());\n            if (parts.length >= 1) attributes.city = parts[0];\n            if (parts.length >= 2) attributes.state = parts[1];\n            if (parts.length >= 3) attributes.country = parts[2];\n        }\n        // Extract preferred causes from opportunity slugs\n        // Try to get cause slugs from opportunity slugs (format: \"opportunity-slug-cause-slug\")\n        const causeKeywords = new Set();\n        registrations.forEach((reg)=>{\n            // Try to extract cause from opportunity slug\n            const slug = reg.opportunitySlug.toLowerCase();\n            const title = reg.opportunityTitle.toLowerCase();\n            // Common cause slugs\n            const causeSlugs = [\n                \"education\",\n                \"environment\",\n                \"healthcare\",\n                \"health\",\n                \"animal-welfare\",\n                \"animal\",\n                \"community-development\",\n                \"community\",\n                \"hunger-relief\",\n                \"hunger\",\n                \"children\",\n                \"elderly\",\n                \"disability\"\n            ];\n            causeSlugs.forEach((causeSlug)=>{\n                if (slug.includes(causeSlug) || title.includes(causeSlug)) {\n                    // Normalize cause slug\n                    const normalized = causeSlug.replace(/-/g, \"-\");\n                    causeKeywords.add(normalized);\n                }\n            });\n        });\n        const causeArray = Array.from(causeKeywords);\n        if (causeArray.length > 0) {\n            attributes.preferredCauses = causeArray;\n            attributes.interests = causeArray;\n        }\n        // Set user type based on registration count\n        if (registrations.length >= 5) {\n            attributes.userType = \"active\";\n        } else if (registrations.length >= 1) {\n            attributes.userType = \"returning\";\n        }\n        attributes.registrationCount = registrations.length;\n        return attributes;\n    } catch (error) {\n        console.error(\"Error extracting user attributes from registrations:\", error);\n        return {};\n    }\n}\n/**\n * Get personalized opportunities based on user attributes\n * This combines regular opportunity fetching with personalization\n */ async function getPersonalizedOpportunities(userAttributes, filters) {\n    // First, get personalized content for opportunity recommendations\n    // Then fetch actual opportunities based on personalized preferences\n    // This is a placeholder - implement based on your Personalize setup\n    // You might want to:\n    // 1. Get personalized cause preferences\n    // 2. Get personalized location preferences\n    // 3. Fetch opportunities matching those preferences\n    return [];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGVudHN0YWNrL3BlcnNvbmFsaXplLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUUrRDtBQXVDaEU7Ozs7Ozs7Q0FPQyxHQUNNLGVBQWVFLHVCQUNwQkMsY0FBc0IsRUFDdEJDLGNBQStCO1FBQy9CQyxVQUFBQSxpRUFBeUUsQ0FBQztJQUUxRSxNQUFNQyxTQUFTTiw4REFBcUJBO0lBQ3BDLE1BQU1PLFVBQVVOLHNEQUFhQTtJQUM3QixNQUFNTyxjQUFjSCxRQUFRRyxXQUFXLElBQUlGLE9BQU9FLFdBQVc7SUFDN0QsTUFBTUMsU0FBU0osUUFBUUksTUFBTSxJQUFJO0lBRWpDLDRCQUE0QjtJQUM1QixNQUFNQyxvQkFBb0JDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsZ0NBQWdDO0lBRXRFLElBQUksQ0FBQ0gsbUJBQW1CO1FBQ3RCSSxRQUFRQyxJQUFJLENBQUM7UUFDYixvQ0FBb0M7UUFDcEMsT0FBT0Msa0JBQXFCYixnQkFBZ0JFLFFBQVFZLFFBQVEsRUFBRVQsYUFBYUM7SUFDN0U7SUFFQSxNQUFNUyxXQUFXYixRQUFRWSxRQUFRLEdBQzdCLGtCQUE0Q1osT0FBMUJGLGdCQUFlLGFBQTRCLE9BQWpCRSxRQUFRWSxRQUFRLElBQzVELGtCQUFpQyxPQUFmZCxnQkFBZTtJQUVyQyxNQUFNZ0IsTUFBTSxHQUFnQkQsT0FBYlgsU0FBUSxPQUE2QkMsT0FBeEJVLFVBQVMsaUJBQXFDVCxPQUF0QkQsYUFBWSxZQUFpQixPQUFQQztJQUUxRSx5Q0FBeUM7SUFDekMsTUFBTVcsVUFBdUI7UUFDM0IsV0FBV2QsT0FBT2UsTUFBTTtRQUN4QixnQkFBZ0JmLE9BQU9nQixhQUFhO1FBQ3BDLDJCQUEyQlo7UUFDM0IsZ0JBQWdCO0lBQ2xCO0lBRUEscURBQXFEO0lBQ3JELGtFQUFrRTtJQUNsRSxNQUFNYSxlQUFlLElBQUlDO0lBRXpCLElBQUlwQixnQkFBZ0I7UUFDbEIsMENBQTBDO1FBQzFDcUIsT0FBT0MsT0FBTyxDQUFDdEIsZ0JBQWdCdUIsT0FBTyxDQUFDO2dCQUFDLENBQUNDLEtBQUtDLE1BQU07WUFDbEQsSUFBSUEsVUFBVUMsV0FBVztnQkFDdkIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxRQUFRO29CQUN4QkEsTUFBTUYsT0FBTyxDQUFDTSxDQUFBQSxJQUFLVixhQUFhVyxNQUFNLENBQUMsbUJBQXVCLE9BQUpOLEtBQUksUUFBTU8sT0FBT0Y7Z0JBQzdFLE9BQU87b0JBQ0xWLGFBQWFXLE1BQU0sQ0FBQyxtQkFBdUIsT0FBSk4sS0FBSSxNQUFJTyxPQUFPTjtnQkFDeEQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxNQUFNTyxVQUFVYixhQUFhYyxRQUFRLEtBQUssR0FBVWQsT0FBUEosS0FBSSxLQUEyQixPQUF4QkksYUFBYWMsUUFBUSxNQUFPbEI7SUFFaEYsSUFBSTtZQVlzQ21CO1FBWHhDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTUosU0FBUztZQUNwQ2hCO1lBQ0FxQixNQUFNO2dCQUFFQyxZQUFZO1lBQUc7UUFDekI7UUFFQSxJQUFJLENBQUNILFNBQVNJLEVBQUUsRUFBRTtZQUNoQjdCLFFBQVFDLElBQUksQ0FBQywwQkFBMEMsT0FBaEJ3QixTQUFTSyxNQUFNLEVBQUM7WUFDdkQsT0FBTzVCLGtCQUFxQmIsZ0JBQWdCRSxRQUFRWSxRQUFRLEVBQUVULGFBQWFDO1FBQzdFO1FBRUEsTUFBTTZCLE9BQU8sTUFBTUMsU0FBU00sSUFBSTtRQUNoQyxPQUFPLENBQUN4QyxRQUFRWSxRQUFRLEdBQUdxQixLQUFLUSxLQUFLLElBQUdSLGdCQUFBQSxLQUFLWixPQUFPLGNBQVpZLG9DQUFBQSxhQUFjLENBQUMsRUFBRSxLQUFLQTtJQUNoRSxFQUFFLE9BQU9TLE9BQU87UUFDZGpDLFFBQVFpQyxLQUFLLENBQUMsd0NBQXdDQTtRQUN0RCw4QkFBOEI7UUFDOUIsT0FBTy9CLGtCQUFxQmIsZ0JBQWdCRSxRQUFRWSxRQUFRLEVBQUVULGFBQWFDO0lBQzdFO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELGVBQWVPLGtCQUNiYixjQUFzQixFQUN0QmMsUUFBNEIsRUFDNUJULFdBQW1CLEVBQ25CQyxNQUFjO1FBd0JrQjZCO0lBdEJoQyxNQUFNaEMsU0FBU04sOERBQXFCQTtJQUNwQyxNQUFNTyxVQUFVTixzREFBYUE7SUFFN0IsTUFBTWlCLFdBQVdELFdBQ2Isa0JBQTRDQSxPQUExQmQsZ0JBQWUsYUFBb0IsT0FBVGMsWUFDNUMsa0JBQWlDLE9BQWZkLGdCQUFlO0lBRXJDLE1BQU1nQixNQUFNLEdBQWdCRCxPQUFiWCxTQUFRLE9BQTZCQyxPQUF4QlUsVUFBUyxpQkFBcUNULE9BQXRCRCxhQUFZLFlBQWlCLE9BQVBDO0lBRTFFLE1BQU04QixXQUFXLE1BQU1DLE1BQU1yQixLQUFLO1FBQ2hDQyxTQUFTO1lBQ1AsV0FBV2QsT0FBT2UsTUFBTTtZQUN4QixnQkFBZ0JmLE9BQU9nQixhQUFhO1FBQ3RDO1FBQ0FtQixNQUFNO1lBQUVDLFlBQVk7UUFBRztJQUN6QjtJQUVBLElBQUksQ0FBQ0gsU0FBU0ksRUFBRSxFQUFFO1FBQ2hCLE1BQU0sSUFBSUssTUFBTSxvQ0FBb0QsT0FBaEJULFNBQVNLLE1BQU07SUFDckU7SUFFQSxNQUFNTixPQUFPLE1BQU1DLFNBQVNNLElBQUk7SUFDaEMsT0FBTyxDQUFDNUIsV0FBV3FCLEtBQUtRLEtBQUssSUFBR1IsZ0JBQUFBLEtBQUtaLE9BQU8sY0FBWlksb0NBQUFBLGFBQWMsQ0FBQyxFQUFFLEtBQUtBO0FBQ3hEO0FBRUE7OztDQUdDLEdBQ00sU0FBU1c7SUFDZCxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFFRCxNQUFNQyxhQUE2QixDQUFDO0lBRXBDLHdCQUF3QjtJQUN4QixNQUFNQyxhQUFhQyxhQUFhQyxPQUFPLENBQUM7SUFDeEMsTUFBTUMsa0JBQWtCRixhQUFhQyxPQUFPLENBQUM7SUFDN0MsTUFBTUUsaUJBQWlCSCxhQUFhQyxPQUFPLENBQUM7SUFFNUMsSUFBSUYsWUFBWUQsV0FBV00sSUFBSSxHQUFHTDtJQUNsQyxJQUFJRyxpQkFBaUI7UUFDbkIsSUFBSTtZQUNGSixXQUFXTyxTQUFTLEdBQUdDLEtBQUtDLEtBQUssQ0FBQ0w7UUFDcEMsRUFBRSxVQUFNO1FBQ04sc0JBQXNCO1FBQ3hCO0lBQ0Y7SUFDQSxJQUFJQyxnQkFBZ0I7UUFDbEJMLFdBQVdVLFFBQVEsR0FBR0w7SUFDeEI7SUFFQSwrQ0FBK0M7SUFDL0MsNENBQTRDO0lBRTVDLE9BQU9MO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNXLG9CQUFvQlgsVUFBbUM7SUFDckUsSUFBSSxLQUFrQixFQUFhLEVBQU87SUFFMUMsSUFBSUEsV0FBV00sSUFBSSxFQUFFO1FBQ25CSixhQUFhVSxPQUFPLENBQUMsWUFBWVosV0FBV00sSUFBSTtJQUNsRDtJQUVBLElBQUlOLFdBQVdPLFNBQVMsRUFBRTtRQUN4QkwsYUFBYVUsT0FBTyxDQUFDLGlCQUFpQkosS0FBS0ssU0FBUyxDQUFDYixXQUFXTyxTQUFTO0lBQzNFO0lBRUEsSUFBSVAsV0FBV1UsUUFBUSxFQUFFO1FBQ3ZCUixhQUFhVSxPQUFPLENBQUMsWUFBWVosV0FBV1UsUUFBUTtJQUN0RDtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ00sU0FBU0ksNEJBT2RDLGFBQWtCLEVBQ2xCN0QsY0FBK0I7UUFNZEEsc0JBQ0NBLHVCQUNFQTtJQU5wQixJQUFJLENBQUNBLGtCQUFrQjZELGNBQWNDLE1BQU0sS0FBSyxHQUFHO1FBQ2pELE9BQU9EO0lBQ1Q7SUFFQSxNQUFNRSxZQUFXL0QsdUJBQUFBLGVBQWVvRCxJQUFJLGNBQW5CcEQsMkNBQUFBLHFCQUFxQmdFLFdBQVc7SUFDakQsTUFBTUMsYUFBWWpFLHdCQUFBQSxlQUFla0UsS0FBSyxjQUFwQmxFLDRDQUFBQSxzQkFBc0JnRSxXQUFXO0lBQ25ELE1BQU1HLGVBQWNuRSwwQkFBQUEsZUFBZW9FLE9BQU8sY0FBdEJwRSw4Q0FBQUEsd0JBQXdCZ0UsV0FBVztJQUN2RCxNQUFNSyxzQkFBc0IsQ0FBQ3JFLGVBQWVzRSxlQUFlLElBQUl0RSxlQUFlcUQsU0FBUyxJQUFJLEVBQUUsRUFDMUZrQixHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVSLFdBQVc7SUFFekIsNENBQTRDO0lBQzVDLE1BQU1TLHNCQUFzQlosY0FBY1UsR0FBRyxDQUFDRyxDQUFBQTtZQUk1QkEsV0FFUUEsWUFFRUE7UUFQMUIsSUFBSUMsUUFBUTtRQUVaLHFDQUFxQztRQUNyQyxJQUFJWixZQUFZVyxFQUFBQSxZQUFBQSxJQUFJdEIsSUFBSSxjQUFSc0IsZ0NBQUFBLFVBQVVWLFdBQVcsUUFBT0QsVUFBVTtZQUNwRFksU0FBUyxLQUFLLG1CQUFtQjtRQUNuQyxPQUFPLElBQUlWLGFBQWFTLEVBQUFBLGFBQUFBLElBQUlSLEtBQUssY0FBVFEsaUNBQUFBLFdBQVdWLFdBQVcsUUFBT0MsV0FBVztZQUM5RFUsU0FBUyxJQUFJLGNBQWM7UUFDN0IsT0FBTyxJQUFJUixlQUFlTyxFQUFBQSxlQUFBQSxJQUFJTixPQUFPLGNBQVhNLG1DQUFBQSxhQUFhVixXQUFXLFFBQU9HLGFBQWE7WUFDcEVRLFNBQVMsSUFBSSxnQkFBZ0I7UUFDL0I7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSUQsSUFBSUUsVUFBVSxJQUFJRixJQUFJRSxVQUFVLENBQUNkLE1BQU0sR0FBRyxLQUFLTyxvQkFBb0JQLE1BQU0sR0FBRyxHQUFHO1lBQ2pGLE1BQU1lLGlCQUFpQkgsSUFBSUUsVUFBVSxDQUFDRSxNQUFNLENBQUNDLENBQUFBLFlBQzNDVixvQkFBb0JXLElBQUksQ0FBQ0MsQ0FBQUEsT0FDdkJGLFVBQVVmLFdBQVcsR0FBR2tCLFFBQVEsQ0FBQ0QsU0FDakNBLEtBQUtDLFFBQVEsQ0FBQ0gsVUFBVWYsV0FBVztZQUd2Q1csU0FBU0UsZUFBZWYsTUFBTSxHQUFHLElBQUksK0JBQStCO1FBQ3RFO1FBRUEsT0FBTztZQUFFcUIsYUFBYVQ7WUFBS0M7UUFBTTtJQUNuQztJQUVBLHVEQUF1RDtJQUN2REYsb0JBQW9CVyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0M7UUFDM0IsSUFBSUEsRUFBRVgsS0FBSyxLQUFLVSxFQUFFVixLQUFLLEVBQUU7WUFDdkIsT0FBT1csRUFBRVgsS0FBSyxHQUFHVSxFQUFFVixLQUFLLEVBQUUscUJBQXFCO1FBQ2pEO1FBQ0EsMERBQTBEO1FBQzFELE9BQU8sSUFBSVksS0FBS0YsRUFBRUYsV0FBVyxDQUFDSyxTQUFTLEVBQUVDLE9BQU8sS0FDekMsSUFBSUYsS0FBS0QsRUFBRUgsV0FBVyxDQUFDSyxTQUFTLEVBQUVDLE9BQU87SUFDbEQ7SUFFQSxPQUFPaEIsb0JBQW9CRixHQUFHLENBQUNtQixDQUFBQSxPQUFRQSxLQUFLUCxXQUFXO0FBQ3pEO0FBRUE7OztDQUdDLEdBQ00sU0FBU1E7SUFDZCxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFFRCxJQUFJO1FBQ0YseUNBQXlDO1FBQ3pDLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7UUFDckMsTUFBTUMsZ0JBQWdCRjtRQUV0QixJQUFJRSxjQUFjaEMsTUFBTSxLQUFLLEdBQUc7WUFDOUIsT0FBTyxDQUFDO1FBQ1Y7UUFFQSxNQUFNaEIsYUFBNkIsQ0FBQztRQUVwQyxrREFBa0Q7UUFDbEQsTUFBTWlELFlBQVlELGNBQ2Z2QixHQUFHLENBQUN5QixDQUFBQSxJQUFLQSxFQUFFQyxtQkFBbUIsRUFDOUJuQixNQUFNLENBQUNvQjtRQUVWLElBQUlILFVBQVVqQyxNQUFNLEdBQUcsR0FBRztZQUN4Qiw0RUFBNEU7WUFDNUUsTUFBTXFDLHFCQUFxQkosU0FBUyxDQUFDLEVBQUU7WUFDdkMsTUFBTUssUUFBUUQsbUJBQW1CRSxLQUFLLENBQUMsS0FBSzlCLEdBQUcsQ0FBQytCLENBQUFBLElBQUtBLEVBQUVDLElBQUk7WUFFM0QsSUFBSUgsTUFBTXRDLE1BQU0sSUFBSSxHQUFHaEIsV0FBV00sSUFBSSxHQUFHZ0QsS0FBSyxDQUFDLEVBQUU7WUFDakQsSUFBSUEsTUFBTXRDLE1BQU0sSUFBSSxHQUFHaEIsV0FBV29CLEtBQUssR0FBR2tDLEtBQUssQ0FBQyxFQUFFO1lBQ2xELElBQUlBLE1BQU10QyxNQUFNLElBQUksR0FBR2hCLFdBQVdzQixPQUFPLEdBQUdnQyxLQUFLLENBQUMsRUFBRTtRQUN0RDtRQUVBLGtEQUFrRDtRQUNsRCx3RkFBd0Y7UUFDeEYsTUFBTUksZ0JBQTZCLElBQUlDO1FBRXZDWCxjQUFjdkUsT0FBTyxDQUFDbUYsQ0FBQUE7WUFDcEIsNkNBQTZDO1lBQzdDLE1BQU1DLE9BQU9ELElBQUlFLGVBQWUsQ0FBQzVDLFdBQVc7WUFDNUMsTUFBTTZDLFFBQVFILElBQUlJLGdCQUFnQixDQUFDOUMsV0FBVztZQUU5QyxxQkFBcUI7WUFDckIsTUFBTVksYUFBYTtnQkFDakI7Z0JBQWE7Z0JBQWU7Z0JBQWM7Z0JBQzFDO2dCQUFrQjtnQkFBVTtnQkFBeUI7Z0JBQ3JEO2dCQUFpQjtnQkFBVTtnQkFBWTtnQkFBVzthQUNuRDtZQUVEQSxXQUFXckQsT0FBTyxDQUFDd0QsQ0FBQUE7Z0JBQ2pCLElBQUk0QixLQUFLekIsUUFBUSxDQUFDSCxjQUFjOEIsTUFBTTNCLFFBQVEsQ0FBQ0gsWUFBWTtvQkFDekQsdUJBQXVCO29CQUN2QixNQUFNZ0MsYUFBYWhDLFVBQVVpQyxPQUFPLENBQUMsTUFBTTtvQkFDM0NSLGNBQWNTLEdBQUcsQ0FBQ0Y7Z0JBQ3BCO1lBQ0Y7UUFDRjtRQUVBLE1BQU1HLGFBQWF2RixNQUFNd0YsSUFBSSxDQUFDWDtRQUU5QixJQUFJVSxXQUFXcEQsTUFBTSxHQUFHLEdBQUc7WUFDekJoQixXQUFXd0IsZUFBZSxHQUFHNEM7WUFDN0JwRSxXQUFXTyxTQUFTLEdBQUc2RDtRQUN6QjtRQUVBLDRDQUE0QztRQUM1QyxJQUFJcEIsY0FBY2hDLE1BQU0sSUFBSSxHQUFHO1lBQzdCaEIsV0FBV1UsUUFBUSxHQUFHO1FBQ3hCLE9BQU8sSUFBSXNDLGNBQWNoQyxNQUFNLElBQUksR0FBRztZQUNwQ2hCLFdBQVdVLFFBQVEsR0FBRztRQUN4QjtRQUVBVixXQUFXc0UsaUJBQWlCLEdBQUd0QixjQUFjaEMsTUFBTTtRQUVuRCxPQUFPaEI7SUFDVCxFQUFFLE9BQU9ILE9BQU87UUFDZGpDLFFBQVFpQyxLQUFLLENBQUMsd0RBQXdEQTtRQUN0RSxPQUFPLENBQUM7SUFDVjtBQUNGO0FBRUE7OztDQUdDLEdBQ00sZUFBZTBFLDZCQUNwQnJILGNBQStCLEVBQy9Cc0gsT0FHQztJQUVELGtFQUFrRTtJQUNsRSxvRUFBb0U7SUFFcEUsb0VBQW9FO0lBQ3BFLHFCQUFxQjtJQUNyQix3Q0FBd0M7SUFDeEMsMkNBQTJDO0lBQzNDLG9EQUFvRDtJQUVwRCxPQUFPLEVBQUU7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2NvbnRlbnRzdGFjay9wZXJzb25hbGl6ZS50cz9mYzRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udGVudHN0YWNrIFBlcnNvbmFsaXplIEludGVncmF0aW9uXG4gKiBcbiAqIFByb3ZpZGVzIHV0aWxpdGllcyBmb3IgZmV0Y2hpbmcgcGVyc29uYWxpemVkIGNvbnRlbnQgYmFzZWQgb24gdXNlciBhdHRyaWJ1dGVzXG4gKiBcbiAqIFNldHVwOlxuICogMS4gRW5hYmxlIFBlcnNvbmFsaXplIGluIHlvdXIgQ29udGVudHN0YWNrIHN0YWNrXG4gKiAyLiBBZGQgQ09OVEVOVFNUQUNLX1BFUlNPTkFMSVpFX0FQSV9LRVkgdG8gLmVudi5sb2NhbFxuICogMy4gQ3JlYXRlIHVzZXIgc2VnbWVudHMgaW4gQ29udGVudHN0YWNrIFBlcnNvbmFsaXplXG4gKiA0LiBBZGQgUGVyc29uYWxpemUgZmllbGRzIHRvIHlvdXIgY29udGVudCB0eXBlc1xuICovXG5cbmltcG9ydCB7IGdldENvbnRlbnRzdGFja0NvbmZpZywgZ2V0QXBpQmFzZVVybCB9IGZyb20gJy4vY29uZmlnJztcblxuZXhwb3J0IGludGVyZmFjZSBVc2VyQXR0cmlidXRlcyB7XG4gIC8vIExvY2F0aW9uXG4gIGNpdHk/OiBzdHJpbmc7XG4gIHN0YXRlPzogc3RyaW5nO1xuICBjb3VudHJ5Pzogc3RyaW5nO1xuICBcbiAgLy8gSW50ZXJlc3RzICYgUHJlZmVyZW5jZXNcbiAgaW50ZXJlc3RzPzogc3RyaW5nW107XG4gIHByZWZlcnJlZENhdXNlcz86IHN0cmluZ1tdO1xuICBjb250cmlidXRpb25UeXBlcz86IHN0cmluZ1tdO1xuICBcbiAgLy8gVXNlciBCZWhhdmlvclxuICB1c2VyVHlwZT86ICduZXcnIHwgJ3JldHVybmluZycgfCAnYWN0aXZlJztcbiAgcmVnaXN0cmF0aW9uQ291bnQ/OiBudW1iZXI7XG4gIGxhc3RWaXNpdERhdGU/OiBzdHJpbmc7XG4gIFxuICAvLyBEZW1vZ3JhcGhpY3MgKG9wdGlvbmFsKVxuICBhZ2U/OiBudW1iZXI7XG4gIGxhbmd1YWdlPzogc3RyaW5nO1xuICBcbiAgLy8gQ3VzdG9tIGF0dHJpYnV0ZXNcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc29uYWxpemVPcHRpb25zIHtcbiAgLyoqIFVzZXIgYXR0cmlidXRlcyBmb3IgcGVyc29uYWxpemF0aW9uICovXG4gIHVzZXJBdHRyaWJ1dGVzPzogVXNlckF0dHJpYnV0ZXM7XG4gIC8qKiBDb250ZW50IHR5cGUgVUlEICovXG4gIGNvbnRlbnRUeXBlVWlkOiBzdHJpbmc7XG4gIC8qKiBFbnRyeSBVSUQgKG9wdGlvbmFsLCBmb3Igc3BlY2lmaWMgZW50cnkpICovXG4gIGVudHJ5VWlkPzogc3RyaW5nO1xuICAvKiogRW52aXJvbm1lbnQgKGRlZmF1bHRzIHRvIGNvbmZpZ3VyZWQgZW52aXJvbm1lbnQpICovXG4gIGVudmlyb25tZW50Pzogc3RyaW5nO1xuICAvKiogTG9jYWxlIChkZWZhdWx0cyB0byAnZW4tdXMnKSAqL1xuICBsb2NhbGU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogR2V0IHBlcnNvbmFsaXplZCBjb250ZW50IGZyb20gQ29udGVudHN0YWNrXG4gKiBcbiAqIEBwYXJhbSBjb250ZW50VHlwZVVpZCAtIENvbnRlbnQgdHlwZSBVSUQgKGUuZy4sICdsYW5kaW5nX3BhZ2UnKVxuICogQHBhcmFtIHVzZXJBdHRyaWJ1dGVzIC0gVXNlciBhdHRyaWJ1dGVzIGZvciBwZXJzb25hbGl6YXRpb25cbiAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJucyBQZXJzb25hbGl6ZWQgY29udGVudCBlbnRyeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGVyc29uYWxpemVkQ29udGVudDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICBjb250ZW50VHlwZVVpZDogc3RyaW5nLFxuICB1c2VyQXR0cmlidXRlcz86IFVzZXJBdHRyaWJ1dGVzLFxuICBvcHRpb25zOiBPbWl0PFBlcnNvbmFsaXplT3B0aW9ucywgJ2NvbnRlbnRUeXBlVWlkJyB8ICd1c2VyQXR0cmlidXRlcyc+ID0ge31cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBjb25maWcgPSBnZXRDb250ZW50c3RhY2tDb25maWcoKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEFwaUJhc2VVcmwoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50IHx8IGNvbmZpZy5lbnZpcm9ubWVudDtcbiAgY29uc3QgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgJ2VuLXVzJztcbiAgXG4gIC8vIEJ1aWxkIFBlcnNvbmFsaXplIEFQSSBVUkxcbiAgY29uc3QgcGVyc29uYWxpemVBcGlLZXkgPSBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfUEVSU09OQUxJWkVfQVBJX0tFWTtcbiAgXG4gIGlmICghcGVyc29uYWxpemVBcGlLZXkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0NPTlRFTlRTVEFDS19QRVJTT05BTElaRV9BUElfS0VZIG5vdCBzZXQuIFJldHVybmluZyBkZWZhdWx0IGNvbnRlbnQuJyk7XG4gICAgLy8gRmFsbGJhY2sgdG8gcmVndWxhciBjb250ZW50IGZldGNoXG4gICAgcmV0dXJuIGdldERlZmF1bHRDb250ZW50PFQ+KGNvbnRlbnRUeXBlVWlkLCBvcHRpb25zLmVudHJ5VWlkLCBlbnZpcm9ubWVudCwgbG9jYWxlKTtcbiAgfVxuICBcbiAgY29uc3QgZW5kcG9pbnQgPSBvcHRpb25zLmVudHJ5VWlkXG4gICAgPyBgL2NvbnRlbnRfdHlwZXMvJHtjb250ZW50VHlwZVVpZH0vZW50cmllcy8ke29wdGlvbnMuZW50cnlVaWR9YFxuICAgIDogYC9jb250ZW50X3R5cGVzLyR7Y29udGVudFR5cGVVaWR9L2VudHJpZXNgO1xuICBcbiAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0vdjMke2VuZHBvaW50fT9lbnZpcm9ubWVudD0ke2Vudmlyb25tZW50fSZsb2NhbGU9JHtsb2NhbGV9YDtcbiAgXG4gIC8vIEJ1aWxkIGhlYWRlcnMgd2l0aCBQZXJzb25hbGl6ZSBBUEkga2V5XG4gIGNvbnN0IGhlYWRlcnM6IEhlYWRlcnNJbml0ID0ge1xuICAgICdhcGlfa2V5JzogY29uZmlnLmFwaUtleSxcbiAgICAnYWNjZXNzX3Rva2VuJzogY29uZmlnLmRlbGl2ZXJ5VG9rZW4sXG4gICAgJ3BlcnNvbmFsaXphdGlvbl9hcGlfa2V5JzogcGVyc29uYWxpemVBcGlLZXksXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfTtcbiAgXG4gIC8vIEFkZCB1c2VyIGF0dHJpYnV0ZXMgYXMgcXVlcnkgcGFyYW1ldGVycyBvciBoZWFkZXJzXG4gIC8vIENvbnRlbnRzdGFjayBQZXJzb25hbGl6ZSBhY2NlcHRzIHVzZXIgYXR0cmlidXRlcyBpbiB0aGUgcmVxdWVzdFxuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIFxuICBpZiAodXNlckF0dHJpYnV0ZXMpIHtcbiAgICAvLyBBZGQgdXNlciBhdHRyaWJ1dGVzIGFzIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICBPYmplY3QuZW50cmllcyh1c2VyQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZS5mb3JFYWNoKHYgPT4gc2VhcmNoUGFyYW1zLmFwcGVuZChgdXNlcl9hdHRyaWJ1dGVzWyR7a2V5fV1bXWAsIFN0cmluZyh2KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoYHVzZXJfYXR0cmlidXRlc1ske2tleX1dYCwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgY29uc3QgZnVsbFVybCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpID8gYCR7dXJsfSYke3NlYXJjaFBhcmFtcy50b1N0cmluZygpfWAgOiB1cmw7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIG5leHQ6IHsgcmV2YWxpZGF0ZTogNjAgfSwgLy8gQ2FjaGUgZm9yIDYwIHNlY29uZHNcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFBlcnNvbmFsaXplIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9LiBGYWxsaW5nIGJhY2sgdG8gZGVmYXVsdCBjb250ZW50LmApO1xuICAgICAgcmV0dXJuIGdldERlZmF1bHRDb250ZW50PFQ+KGNvbnRlbnRUeXBlVWlkLCBvcHRpb25zLmVudHJ5VWlkLCBlbnZpcm9ubWVudCwgbG9jYWxlKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gKG9wdGlvbnMuZW50cnlVaWQgPyBkYXRhLmVudHJ5IDogZGF0YS5lbnRyaWVzPy5bMF0pIHx8IGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGVyc29uYWxpemVkIGNvbnRlbnQ6JywgZXJyb3IpO1xuICAgIC8vIEZhbGxiYWNrIHRvIGRlZmF1bHQgY29udGVudFxuICAgIHJldHVybiBnZXREZWZhdWx0Q29udGVudDxUPihjb250ZW50VHlwZVVpZCwgb3B0aW9ucy5lbnRyeVVpZCwgZW52aXJvbm1lbnQsIGxvY2FsZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWxsYmFjazogR2V0IGRlZmF1bHQgKG5vbi1wZXJzb25hbGl6ZWQpIGNvbnRlbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbnRlbnQ8VD4oXG4gIGNvbnRlbnRUeXBlVWlkOiBzdHJpbmcsXG4gIGVudHJ5VWlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGVudmlyb25tZW50OiBzdHJpbmcsXG4gIGxvY2FsZTogc3RyaW5nXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgY29uZmlnID0gZ2V0Q29udGVudHN0YWNrQ29uZmlnKCk7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRBcGlCYXNlVXJsKCk7XG4gIFxuICBjb25zdCBlbmRwb2ludCA9IGVudHJ5VWlkXG4gICAgPyBgL2NvbnRlbnRfdHlwZXMvJHtjb250ZW50VHlwZVVpZH0vZW50cmllcy8ke2VudHJ5VWlkfWBcbiAgICA6IGAvY29udGVudF90eXBlcy8ke2NvbnRlbnRUeXBlVWlkfS9lbnRyaWVzYDtcbiAgXG4gIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9L3YzJHtlbmRwb2ludH0/ZW52aXJvbm1lbnQ9JHtlbnZpcm9ubWVudH0mbG9jYWxlPSR7bG9jYWxlfWA7XG4gIFxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICdhcGlfa2V5JzogY29uZmlnLmFwaUtleSxcbiAgICAgICdhY2Nlc3NfdG9rZW4nOiBjb25maWcuZGVsaXZlcnlUb2tlbixcbiAgICB9LFxuICAgIG5leHQ6IHsgcmV2YWxpZGF0ZTogNjAgfSxcbiAgfSk7XG4gIFxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGVmYXVsdCBjb250ZW50OiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgfVxuICBcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgcmV0dXJuIChlbnRyeVVpZCA/IGRhdGEuZW50cnkgOiBkYXRhLmVudHJpZXM/LlswXSkgfHwgZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdXNlciBhdHRyaWJ1dGVzIGZyb20gY2xpZW50LXNpZGUgc3RvcmFnZSAobG9jYWxTdG9yYWdlLCBjb29raWVzLCBldGMuKVxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgY2xpZW50IGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBdHRyaWJ1dGVzRnJvbUNsaWVudCgpOiBVc2VyQXR0cmlidXRlcyB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBcbiAgY29uc3QgYXR0cmlidXRlczogVXNlckF0dHJpYnV0ZXMgPSB7fTtcbiAgXG4gIC8vIEdldCBmcm9tIGxvY2FsU3RvcmFnZVxuICBjb25zdCBzdG9yZWRDaXR5ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJDaXR5Jyk7XG4gIGNvbnN0IHN0b3JlZEludGVyZXN0cyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VySW50ZXJlc3RzJyk7XG4gIGNvbnN0IHN0b3JlZFVzZXJUeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJUeXBlJyk7XG4gIFxuICBpZiAoc3RvcmVkQ2l0eSkgYXR0cmlidXRlcy5jaXR5ID0gc3RvcmVkQ2l0eTtcbiAgaWYgKHN0b3JlZEludGVyZXN0cykge1xuICAgIHRyeSB7XG4gICAgICBhdHRyaWJ1dGVzLmludGVyZXN0cyA9IEpTT04ucGFyc2Uoc3RvcmVkSW50ZXJlc3RzKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElnbm9yZSBwYXJzZSBlcnJvcnNcbiAgICB9XG4gIH1cbiAgaWYgKHN0b3JlZFVzZXJUeXBlKSB7XG4gICAgYXR0cmlidXRlcy51c2VyVHlwZSA9IHN0b3JlZFVzZXJUeXBlIGFzICduZXcnIHwgJ3JldHVybmluZycgfCAnYWN0aXZlJztcbiAgfVxuICBcbiAgLy8gR2V0IGZyb20gY29va2llcyAoaWYgdXNpbmcgYSBjb29raWUgbGlicmFyeSlcbiAgLy8gWW91IGNhbiBhZGQgY29va2llIHBhcnNpbmcgaGVyZSBpZiBuZWVkZWRcbiAgXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIFN0b3JlIHVzZXIgYXR0cmlidXRlcyBpbiBjbGllbnQtc2lkZSBzdG9yYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZVVzZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IFBhcnRpYWw8VXNlckF0dHJpYnV0ZXM+KTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKGF0dHJpYnV0ZXMuY2l0eSkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyQ2l0eScsIGF0dHJpYnV0ZXMuY2l0eSk7XG4gIH1cbiAgXG4gIGlmIChhdHRyaWJ1dGVzLmludGVyZXN0cykge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VySW50ZXJlc3RzJywgSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlcy5pbnRlcmVzdHMpKTtcbiAgfVxuICBcbiAgaWYgKGF0dHJpYnV0ZXMudXNlclR5cGUpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlclR5cGUnLCBhdHRyaWJ1dGVzLnVzZXJUeXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcnNvbmFsaXplIG9wcG9ydHVuaXR5IG9yZGVyaW5nIGJhc2VkIG9uIHVzZXIgYXR0cmlidXRlc1xuICogUHJpb3JpdHk6XG4gKiAxLiBMb2NhdGlvbiBtYXRjaCAoY2l0eSwgc3RhdGUsIGNvdW50cnkpXG4gKiAyLiBDYXVzZSBtYXRjaCAoY2F1c2VzIHVzZXIgaGFzIHJlZ2lzdGVyZWQgZm9yKVxuICogMy4gRGVmYXVsdCBvcmRlciAoZGF0ZSBhc2NlbmRpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJzb25hbGl6ZU9wcG9ydHVuaXR5T3JkZXI8VCBleHRlbmRzIHtcbiAgY2l0eT86IHN0cmluZztcbiAgc3RhdGU/OiBzdHJpbmc7XG4gIGNvdW50cnk/OiBzdHJpbmc7XG4gIGNhdXNlU2x1Z3M/OiBzdHJpbmdbXTtcbiAgc3RhcnREYXRlOiBzdHJpbmc7XG59PihcbiAgb3Bwb3J0dW5pdGllczogVFtdLFxuICB1c2VyQXR0cmlidXRlcz86IFVzZXJBdHRyaWJ1dGVzXG4pOiBUW10ge1xuICBpZiAoIXVzZXJBdHRyaWJ1dGVzIHx8IG9wcG9ydHVuaXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9wcG9ydHVuaXRpZXM7XG4gIH1cblxuICBjb25zdCB1c2VyQ2l0eSA9IHVzZXJBdHRyaWJ1dGVzLmNpdHk/LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHVzZXJTdGF0ZSA9IHVzZXJBdHRyaWJ1dGVzLnN0YXRlPy50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCB1c2VyQ291bnRyeSA9IHVzZXJBdHRyaWJ1dGVzLmNvdW50cnk/LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHVzZXJQcmVmZXJyZWRDYXVzZXMgPSAodXNlckF0dHJpYnV0ZXMucHJlZmVycmVkQ2F1c2VzIHx8IHVzZXJBdHRyaWJ1dGVzLmludGVyZXN0cyB8fCBbXSlcbiAgICAubWFwKGMgPT4gYy50b0xvd2VyQ2FzZSgpKTtcblxuICAvLyBTY29yZSBlYWNoIG9wcG9ydHVuaXR5IGJhc2VkIG9uIHJlbGV2YW5jZVxuICBjb25zdCBzY29yZWRPcHBvcnR1bml0aWVzID0gb3Bwb3J0dW5pdGllcy5tYXAob3BwID0+IHtcbiAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgLy8gTG9jYXRpb24gc2NvcmluZyAoaGlnaGVyIHByaW9yaXR5KVxuICAgIGlmICh1c2VyQ2l0eSAmJiBvcHAuY2l0eT8udG9Mb3dlckNhc2UoKSA9PT0gdXNlckNpdHkpIHtcbiAgICAgIHNjb3JlICs9IDEwMDsgLy8gRXhhY3QgY2l0eSBtYXRjaFxuICAgIH0gZWxzZSBpZiAodXNlclN0YXRlICYmIG9wcC5zdGF0ZT8udG9Mb3dlckNhc2UoKSA9PT0gdXNlclN0YXRlKSB7XG4gICAgICBzY29yZSArPSA1MDsgLy8gU3RhdGUgbWF0Y2hcbiAgICB9IGVsc2UgaWYgKHVzZXJDb3VudHJ5ICYmIG9wcC5jb3VudHJ5Py50b0xvd2VyQ2FzZSgpID09PSB1c2VyQ291bnRyeSkge1xuICAgICAgc2NvcmUgKz0gMjU7IC8vIENvdW50cnkgbWF0Y2hcbiAgICB9XG5cbiAgICAvLyBDYXVzZSBzY29yaW5nIChzZWNvbmRhcnkgcHJpb3JpdHkpXG4gICAgaWYgKG9wcC5jYXVzZVNsdWdzICYmIG9wcC5jYXVzZVNsdWdzLmxlbmd0aCA+IDAgJiYgdXNlclByZWZlcnJlZENhdXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXRjaGluZ0NhdXNlcyA9IG9wcC5jYXVzZVNsdWdzLmZpbHRlcihjYXVzZVNsdWcgPT5cbiAgICAgICAgdXNlclByZWZlcnJlZENhdXNlcy5zb21lKHByZWYgPT4gXG4gICAgICAgICAgY2F1c2VTbHVnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocHJlZikgfHwgXG4gICAgICAgICAgcHJlZi5pbmNsdWRlcyhjYXVzZVNsdWcudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHNjb3JlICs9IG1hdGNoaW5nQ2F1c2VzLmxlbmd0aCAqIDEwOyAvLyAxMCBwb2ludHMgcGVyIG1hdGNoaW5nIGNhdXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgb3Bwb3J0dW5pdHk6IG9wcCwgc2NvcmUgfTtcbiAgfSk7XG5cbiAgLy8gU29ydCBieSBzY29yZSAoZGVzY2VuZGluZyksIHRoZW4gYnkgZGF0ZSAoYXNjZW5kaW5nKVxuICBzY29yZWRPcHBvcnR1bml0aWVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYi5zY29yZSAhPT0gYS5zY29yZSkge1xuICAgICAgcmV0dXJuIGIuc2NvcmUgLSBhLnNjb3JlOyAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICB9XG4gICAgLy8gSWYgc2NvcmVzIGFyZSBlcXVhbCwgc29ydCBieSBkYXRlIChlYXJsaWVyIGRhdGVzIGZpcnN0KVxuICAgIHJldHVybiBuZXcgRGF0ZShhLm9wcG9ydHVuaXR5LnN0YXJ0RGF0ZSkuZ2V0VGltZSgpIC0gXG4gICAgICAgICAgIG5ldyBEYXRlKGIub3Bwb3J0dW5pdHkuc3RhcnREYXRlKS5nZXRUaW1lKCk7XG4gIH0pO1xuXG4gIHJldHVybiBzY29yZWRPcHBvcnR1bml0aWVzLm1hcChpdGVtID0+IGl0ZW0ub3Bwb3J0dW5pdHkpO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdXNlciBhdHRyaWJ1dGVzIGZyb20gcmVnaXN0cmF0aW9uc1xuICogR2V0cyBsb2NhdGlvbiBhbmQgcHJlZmVycmVkIGNhdXNlcyBmcm9tIHVzZXIncyByZWdpc3RyYXRpb24gaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckF0dHJpYnV0ZXNGcm9tUmVnaXN0cmF0aW9ucygpOiBVc2VyQXR0cmlidXRlcyB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gSW1wb3J0IGR5bmFtaWNhbGx5IHRvIGF2b2lkIFNTUiBpc3N1ZXNcbiAgICBjb25zdCB7IGdldFJlZ2lzdHJhdGlvbnMgfSA9IHJlcXVpcmUoJ0AvbGliL3VzZXInKTtcbiAgICBjb25zdCByZWdpc3RyYXRpb25zID0gZ2V0UmVnaXN0cmF0aW9ucygpO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlczogVXNlckF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIC8vIEV4dHJhY3QgbW9zdCBjb21tb24gbG9jYXRpb24gZnJvbSByZWdpc3RyYXRpb25zXG4gICAgY29uc3QgbG9jYXRpb25zID0gcmVnaXN0cmF0aW9uc1xuICAgICAgLm1hcChyID0+IHIub3Bwb3J0dW5pdHlMb2NhdGlvbilcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgXG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBUcnkgdG8gZXh0cmFjdCBjaXR5IGZyb20gbG9jYXRpb24gc3RyaW5nIChmb3JtYXQ6IFwiQ2l0eSwgU3RhdGUsIENvdW50cnlcIilcbiAgICAgIGNvbnN0IG1vc3RDb21tb25Mb2NhdGlvbiA9IGxvY2F0aW9uc1swXTtcbiAgICAgIGNvbnN0IHBhcnRzID0gbW9zdENvbW1vbkxvY2F0aW9uLnNwbGl0KCcsJykubWFwKHAgPT4gcC50cmltKCkpO1xuICAgICAgXG4gICAgICBpZiAocGFydHMubGVuZ3RoID49IDEpIGF0dHJpYnV0ZXMuY2l0eSA9IHBhcnRzWzBdO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSBhdHRyaWJ1dGVzLnN0YXRlID0gcGFydHNbMV07XG4gICAgICBpZiAocGFydHMubGVuZ3RoID49IDMpIGF0dHJpYnV0ZXMuY291bnRyeSA9IHBhcnRzWzJdO1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgcHJlZmVycmVkIGNhdXNlcyBmcm9tIG9wcG9ydHVuaXR5IHNsdWdzXG4gICAgLy8gVHJ5IHRvIGdldCBjYXVzZSBzbHVncyBmcm9tIG9wcG9ydHVuaXR5IHNsdWdzIChmb3JtYXQ6IFwib3Bwb3J0dW5pdHktc2x1Zy1jYXVzZS1zbHVnXCIpXG4gICAgY29uc3QgY2F1c2VLZXl3b3JkczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKHJlZyA9PiB7XG4gICAgICAvLyBUcnkgdG8gZXh0cmFjdCBjYXVzZSBmcm9tIG9wcG9ydHVuaXR5IHNsdWdcbiAgICAgIGNvbnN0IHNsdWcgPSByZWcub3Bwb3J0dW5pdHlTbHVnLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCB0aXRsZSA9IHJlZy5vcHBvcnR1bml0eVRpdGxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBcbiAgICAgIC8vIENvbW1vbiBjYXVzZSBzbHVnc1xuICAgICAgY29uc3QgY2F1c2VTbHVncyA9IFtcbiAgICAgICAgJ2VkdWNhdGlvbicsICdlbnZpcm9ubWVudCcsICdoZWFsdGhjYXJlJywgJ2hlYWx0aCcsIFxuICAgICAgICAnYW5pbWFsLXdlbGZhcmUnLCAnYW5pbWFsJywgJ2NvbW11bml0eS1kZXZlbG9wbWVudCcsICdjb21tdW5pdHknLFxuICAgICAgICAnaHVuZ2VyLXJlbGllZicsICdodW5nZXInLCAnY2hpbGRyZW4nLCAnZWxkZXJseScsICdkaXNhYmlsaXR5J1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgY2F1c2VTbHVncy5mb3JFYWNoKGNhdXNlU2x1ZyA9PiB7XG4gICAgICAgIGlmIChzbHVnLmluY2x1ZGVzKGNhdXNlU2x1ZykgfHwgdGl0bGUuaW5jbHVkZXMoY2F1c2VTbHVnKSkge1xuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBjYXVzZSBzbHVnXG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGNhdXNlU2x1Zy5yZXBsYWNlKC8tL2csICctJyk7XG4gICAgICAgICAgY2F1c2VLZXl3b3Jkcy5hZGQobm9ybWFsaXplZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY2F1c2VBcnJheSA9IEFycmF5LmZyb20oY2F1c2VLZXl3b3Jkcyk7XG5cbiAgICBpZiAoY2F1c2VBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzLnByZWZlcnJlZENhdXNlcyA9IGNhdXNlQXJyYXk7XG4gICAgICBhdHRyaWJ1dGVzLmludGVyZXN0cyA9IGNhdXNlQXJyYXk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHVzZXIgdHlwZSBiYXNlZCBvbiByZWdpc3RyYXRpb24gY291bnRcbiAgICBpZiAocmVnaXN0cmF0aW9ucy5sZW5ndGggPj0gNSkge1xuICAgICAgYXR0cmlidXRlcy51c2VyVHlwZSA9ICdhY3RpdmUnO1xuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9ucy5sZW5ndGggPj0gMSkge1xuICAgICAgYXR0cmlidXRlcy51c2VyVHlwZSA9ICdyZXR1cm5pbmcnO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMucmVnaXN0cmF0aW9uQ291bnQgPSByZWdpc3RyYXRpb25zLmxlbmd0aDtcblxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgdXNlciBhdHRyaWJ1dGVzIGZyb20gcmVnaXN0cmF0aW9uczonLCBlcnJvcik7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8qKlxuICogR2V0IHBlcnNvbmFsaXplZCBvcHBvcnR1bml0aWVzIGJhc2VkIG9uIHVzZXIgYXR0cmlidXRlc1xuICogVGhpcyBjb21iaW5lcyByZWd1bGFyIG9wcG9ydHVuaXR5IGZldGNoaW5nIHdpdGggcGVyc29uYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZXJzb25hbGl6ZWRPcHBvcnR1bml0aWVzKFxuICB1c2VyQXR0cmlidXRlcz86IFVzZXJBdHRyaWJ1dGVzLFxuICBmaWx0ZXJzPzoge1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHN0YXR1cz86IHN0cmluZ1tdO1xuICB9XG4pIHtcbiAgLy8gRmlyc3QsIGdldCBwZXJzb25hbGl6ZWQgY29udGVudCBmb3Igb3Bwb3J0dW5pdHkgcmVjb21tZW5kYXRpb25zXG4gIC8vIFRoZW4gZmV0Y2ggYWN0dWFsIG9wcG9ydHVuaXRpZXMgYmFzZWQgb24gcGVyc29uYWxpemVkIHByZWZlcmVuY2VzXG4gIFxuICAvLyBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgLSBpbXBsZW1lbnQgYmFzZWQgb24geW91ciBQZXJzb25hbGl6ZSBzZXR1cFxuICAvLyBZb3UgbWlnaHQgd2FudCB0bzpcbiAgLy8gMS4gR2V0IHBlcnNvbmFsaXplZCBjYXVzZSBwcmVmZXJlbmNlc1xuICAvLyAyLiBHZXQgcGVyc29uYWxpemVkIGxvY2F0aW9uIHByZWZlcmVuY2VzXG4gIC8vIDMuIEZldGNoIG9wcG9ydHVuaXRpZXMgbWF0Y2hpbmcgdGhvc2UgcHJlZmVyZW5jZXNcbiAgXG4gIHJldHVybiBbXTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRDb250ZW50c3RhY2tDb25maWciLCJnZXRBcGlCYXNlVXJsIiwiZ2V0UGVyc29uYWxpemVkQ29udGVudCIsImNvbnRlbnRUeXBlVWlkIiwidXNlckF0dHJpYnV0ZXMiLCJvcHRpb25zIiwiY29uZmlnIiwiYmFzZVVybCIsImVudmlyb25tZW50IiwibG9jYWxlIiwicGVyc29uYWxpemVBcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiQ09OVEVOVFNUQUNLX1BFUlNPTkFMSVpFX0FQSV9LRVkiLCJjb25zb2xlIiwid2FybiIsImdldERlZmF1bHRDb250ZW50IiwiZW50cnlVaWQiLCJlbmRwb2ludCIsInVybCIsImhlYWRlcnMiLCJhcGlLZXkiLCJkZWxpdmVyeVRva2VuIiwic2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJhcHBlbmQiLCJTdHJpbmciLCJmdWxsVXJsIiwidG9TdHJpbmciLCJkYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm5leHQiLCJyZXZhbGlkYXRlIiwib2siLCJzdGF0dXMiLCJqc29uIiwiZW50cnkiLCJlcnJvciIsIkVycm9yIiwiZ2V0VXNlckF0dHJpYnV0ZXNGcm9tQ2xpZW50IiwiYXR0cmlidXRlcyIsInN0b3JlZENpdHkiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic3RvcmVkSW50ZXJlc3RzIiwic3RvcmVkVXNlclR5cGUiLCJjaXR5IiwiaW50ZXJlc3RzIiwiSlNPTiIsInBhcnNlIiwidXNlclR5cGUiLCJzdG9yZVVzZXJBdHRyaWJ1dGVzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInBlcnNvbmFsaXplT3Bwb3J0dW5pdHlPcmRlciIsIm9wcG9ydHVuaXRpZXMiLCJsZW5ndGgiLCJ1c2VyQ2l0eSIsInRvTG93ZXJDYXNlIiwidXNlclN0YXRlIiwic3RhdGUiLCJ1c2VyQ291bnRyeSIsImNvdW50cnkiLCJ1c2VyUHJlZmVycmVkQ2F1c2VzIiwicHJlZmVycmVkQ2F1c2VzIiwibWFwIiwiYyIsInNjb3JlZE9wcG9ydHVuaXRpZXMiLCJvcHAiLCJzY29yZSIsImNhdXNlU2x1Z3MiLCJtYXRjaGluZ0NhdXNlcyIsImZpbHRlciIsImNhdXNlU2x1ZyIsInNvbWUiLCJwcmVmIiwiaW5jbHVkZXMiLCJvcHBvcnR1bml0eSIsInNvcnQiLCJhIiwiYiIsIkRhdGUiLCJzdGFydERhdGUiLCJnZXRUaW1lIiwiaXRlbSIsImdldFVzZXJBdHRyaWJ1dGVzRnJvbVJlZ2lzdHJhdGlvbnMiLCJnZXRSZWdpc3RyYXRpb25zIiwicmVxdWlyZSIsInJlZ2lzdHJhdGlvbnMiLCJsb2NhdGlvbnMiLCJyIiwib3Bwb3J0dW5pdHlMb2NhdGlvbiIsIkJvb2xlYW4iLCJtb3N0Q29tbW9uTG9jYXRpb24iLCJwYXJ0cyIsInNwbGl0IiwicCIsInRyaW0iLCJjYXVzZUtleXdvcmRzIiwiU2V0IiwicmVnIiwic2x1ZyIsIm9wcG9ydHVuaXR5U2x1ZyIsInRpdGxlIiwib3Bwb3J0dW5pdHlUaXRsZSIsIm5vcm1hbGl6ZWQiLCJyZXBsYWNlIiwiYWRkIiwiY2F1c2VBcnJheSIsImZyb20iLCJyZWdpc3RyYXRpb25Db3VudCIsImdldFBlcnNvbmFsaXplZE9wcG9ydHVuaXRpZXMiLCJmaWx0ZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contentstack/personalize.ts\n"));

/***/ })

});